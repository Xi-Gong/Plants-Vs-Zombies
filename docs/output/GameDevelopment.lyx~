#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass ctex-article
\begin_preamble

\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language chinese-simplified
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts true
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing onehalf
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\headheight 1cm
\headsep 1cm
\secnumdepth 4
\tocdepth 5
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section
选题
\end_layout

\begin_layout Standard
关于练手项目，选择时考虑的因素： 
\end_layout

\begin_layout Enumerate
主要目的是将所需C++知识、开发过程、软件系统分析与设计能力融汇贯通。 达成，植物大战僵尸项目用到了上述知识。
\end_layout

\begin_layout Enumerate
项目的目标不要高，开发该项目不要涉及过多的自己不懂的专业知识。 达成，植物大战僵尸项目使用cocos2dx，学习成本较低。
\end_layout

\begin_layout Enumerate
项目的规模不要大，代码行在1000~2000行，开发周期在半个月左右。未达成，植物大战僵尸项目的规模远远超乎想象。
\end_layout

\begin_layout Standard
参考以上三点因素，得出项目规模等同于期末大作业的结论，因此将搜索范围划定为各高校C++期末大作业。另外考虑到个人兴趣，决定进行游戏开发，在这个方向上有同济大学和
中国人民大学的大作业文档作为参考，大作业文档存放在Game/docs。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
https://www.zhihu.com/question/393933369/answer/1216606194，同济大学C++大作业，开心消消乐或元气骑士（团
队开发）。
\end_layout

\begin_layout Standard
https://www.zhihu.com/question/391116845/answer/1207072945，中国人民大学C++大作业，塔防游戏（单人开发）
。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
游戏感兴趣的选题有僵尸危机、植物大战僵尸和王国保卫战。其中对植物大战僵尸最为熟悉，并且该游戏有许多爱好者复现，资源丰富，因此决定开发本游戏。
\end_layout

\begin_layout Subsection
僵尸危机（Boxhead）
\end_layout

\begin_layout Standard
参考同济大学大作业中的元气骑士，相似的游戏有曾经比较火的僵尸危机小游戏。该游戏采用Flash开发，已经过时，并且不再维护。由于该游戏画面简洁、规则简单，有爱好者
自行开发了相似的游戏。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
http://www.boxheadx.com/，Boxhead官方网站，运行游戏需要Flash。
\end_layout

\begin_layout Standard
https://github.com/emilegascoin/BoxHead，Java开发的Boxhead，有少量文档，但是界面过于简单，和实际游戏相差较大。
\end_layout

\begin_layout Standard
https://github.com/sdamghan/BoxHead，C++开发的Boxhead游戏，使用SDL库，代码行数在3000-5000之间，界面资源引
自游戏原版素材，但是没有文档，参考价值不大。
\end_layout

\begin_layout Standard
https://github.com/EverardoG/boxhead_cpp，未完成开发的Boxhead，目录结构比较清晰。
\end_layout

\begin_layout Subsection
植物大战僵尸（Plants Vs Zombies）
\end_layout

\begin_layout Standard
参考中国人大大作业的塔防游戏，是个热门选题。植物大战僵尸可以说是人尽皆知的游戏，有广泛的用户群体和爱好者。该游戏已经有业余开发者完成开发，比原版游戏的体验还好。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
https://www.ea.com/games/plants-vs-zombies，官方网站。
\end_layout

\begin_layout Standard
https://www.spriters-resource.com/ds_dsi/pvszds/，植物大战僵尸多媒体资源。
\end_layout

\begin_layout Standard
https://pvzcc.fandom.com/wiki/Page_of_Resources，零碎的多媒体资源。
\end_layout

\begin_layout Standard
https://github.com/ErLinErYi/PlantsVsZombies，1.1k星，C++和CMake开发，使用Cocos2d-X，支持多平台，游
戏体验逼真，文档较多，其中多媒体资源需要联系作者获取。
\end_layout

\begin_layout Standard
https://blog.csdn.net/qq_40630246/article/details/102643196，1.1k星项目作者的博客，给出更详细的更新日志
。
\end_layout

\begin_layout Standard
https://github.com/marblexu/PythonPlantsVsZombies，2.5k星，完全由python开发，游戏体验尚可，有多媒体资源。
\end_layout

\begin_layout Standard
https://github.com/chaoyang805/PlantsVsZombies，Cocos2d-x开发，没有文档，但是给出了多媒体资源。
\end_layout

\begin_layout Standard
https://github.com/yangsheng6810/pvz，C++开发，给出了多媒体资源。
\end_layout

\begin_layout Standard
https://github.com/Zhuagenborn/Plants-vs.-Zombies-Online-Battle，374星，C++开发，画风接近原版游
戏。
\end_layout

\begin_layout Subsection
王国保卫战（KingdomRush）
\end_layout

\begin_layout Standard
参考中国人大大作业的塔防游戏，是个较热门选题。该游戏界面简洁，规则有趣，有爱好者对其进行了复现，不过尚没有一个C++项目随附完整的文档和多媒体资源。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
https://github.com/wuhaoyu1990/KingdomRush，154星（Github最高），C++开发，采用Cocos2dx，但是截止20
16年就没有再维护，没有公布多媒体资源。
\end_layout

\begin_layout Standard
https://github.com/exmex/KingdomRushFrontiers，57星，同样采用Cocos2dx开发（C++），公布了多媒体资源，最后
一次更新截止2019年。
\end_layout

\begin_layout Section
基本要求
\end_layout

\begin_layout Standard
在实现基础功能的前提下，参考同济大学大作业要求，制定以下基本要求。
\end_layout

\begin_layout Standard
本次项目旨在锻炼面向对象程序设计的能力，重点在于对类、继承、多态等面向对象程序设计特点以及对于复杂C++类库的使用。
\end_layout

\begin_layout Subsubsection
游戏引擎
\end_layout

\begin_layout Standard
统一使用Cocos2d-x游戏开发框架，不得只包含控制台界面。本项目偏向于锻炼代码和架构设计，请勿将重点错误地放在精美的界面上。
\end_layout

\begin_layout Subsubsection
代码质量和安全
\end_layout

\begin_layout Itemize
没有内存泄露，程序很少崩溃。
\end_layout

\begin_layout Itemize
对于复杂逻辑使用单元测试验证正确性。
\end_layout

\begin_layout Itemize
使用断言验证程序性质。
\end_layout

\begin_layout Itemize
合理的异常抛出与处理。
\end_layout

\begin_layout Subsubsection
代码规范
\end_layout

\begin_layout Itemize
代码在缩进、命名等方面基本遵循了统一的风格（如Google C++ Style）
\end_layout

\begin_layout Itemize
正确地使用C++风格类型转换（如static_cast、dynamic_cast）且没有使用C风格强制转换。
\end_layout

\begin_layout Itemize
尽可能地使用const和引用。
\end_layout

\begin_layout Itemize
类的设计合理规范。
\end_layout

\begin_layout Subsubsection
代码抄袭
\end_layout

\begin_layout Standard
允许借鉴开源项目代码，但应在学习他人写法的基础上，自己完成编写，且在文档中注明参考链接。
\end_layout

\begin_layout Subsubsection
开发平台和IDE
\end_layout

\begin_layout Standard
开发平台选用Ubuntu 22.10，IDE定为QtCreator。
\end_layout

\begin_layout Subsubsection
架构
\end_layout

\begin_layout Standard
统一使用cmake组织目录结构，要求项目目录结构良好、清晰。
\end_layout

\begin_layout Subsubsection
C++新特性
\end_layout

\begin_layout Standard
项目使用C++17标准，要求合理地使用下列3条以上的C++新特性。
\end_layout

\begin_layout Itemize
初始化列表
\end_layout

\begin_layout Itemize
类型推断（auto / decltype）
\end_layout

\begin_layout Itemize
基于范围的for循环
\end_layout

\begin_layout Itemize
智能指针
\end_layout

\begin_layout Itemize
常量表达式（constexpr）
\end_layout

\begin_layout Itemize
Lambda表达式
\end_layout

\begin_layout Itemize
右值引用
\end_layout

\begin_layout Itemize
字符串字面量
\end_layout

\begin_layout Itemize
其他C++11或更高的新特性
\end_layout

\begin_layout Subsubsection
C++功能
\end_layout

\begin_layout Standard
要求合理地使用下列3条以上的C++功能。
\end_layout

\begin_layout Itemize
STL容器
\end_layout

\begin_layout Itemize
迭代器
\end_layout

\begin_layout Itemize
类和多态
\end_layout

\begin_layout Itemize
模板
\end_layout

\begin_layout Itemize
异常
\end_layout

\begin_layout Itemize
函数重载
\end_layout

\begin_layout Itemize
运算符重载
\end_layout

\begin_layout Subsubsection
版本控制与团队协作
\end_layout

\begin_layout Itemize
项目必须使用Git版本控制，最终需发布在Github，注意保留每个人的提交记录。
\end_layout

\begin_layout Itemize
遵循git最佳实践（如commit历史干净规范、commit描述规范、commit包含且仅包含一项功能、使用Pull Request功能或分支进行团队协作等）。
\end_layout

\begin_layout Itemize
团队成员分工需要平等、合理。
\end_layout

\begin_layout Subsubsection
文档
\end_layout

\begin_layout Standard
使用Lyx编写项目文档。
\end_layout

\begin_layout Section
功能要求
\end_layout

\begin_layout Standard
由于本项目基于LZ项目开发，而LZ项目功能比较全面，因此将在功能方面进行简化。但是为了保证项目结构的完整性，不能一味对功能进行简化，还是要适当的保留一些功能，即
使用处不大。
\end_layout

\begin_layout Subsubsection
已经实现的功能和界面
\end_layout

\begin_layout Enumerate
主菜单界面、下分用户存档选择界面、用户设置界面和退出界面。游戏属性设置和用户存档功能。
\end_layout

\begin_layout Enumerate
关卡选择界面。关卡选择功能。
\end_layout

\begin_layout Enumerate
选择植物界面。选择植物功能，预览本关卡僵尸种类和数量功能，用户设置功能（重用）。
\end_layout

\begin_layout Enumerate
对战界面。种植
\backslash
铲除植物功能，除草机功能，僵尸死亡和关卡结束掉落金币功能，用户设置功能（重用），其他基本的对战功能。
\end_layout

\begin_layout Enumerate
游戏结束界面。植物胜利后奖励一包金币，僵尸胜利后显示被吃掉脑子。
\end_layout

\begin_layout Subsubsection
未来考虑实现的功能和界面
\end_layout

\begin_layout Enumerate
不同关卡显示不同的背景和音乐。
\end_layout

\begin_layout Enumerate
允许存档当前对战的状态。
\end_layout

\begin_layout Enumerate
关卡随着通关一步步解锁，而不是一次性全部解锁。
\end_layout

\begin_layout Enumerate
增加植物和僵尸种类。
\end_layout

\begin_layout Enumerate
自己制作游戏素材，去除水印。
\end_layout

\begin_layout Subsubsection
暂不实现的功能和界面
\end_layout

\begin_layout Enumerate
冒险游戏下的游戏类型功能，比如通关必须保留5辆小车，不能让僵尸踩坏花坛等要求。
\end_layout

\begin_layout Enumerate
彩蛋功能，该功能在LZ项目中存在bug。
\end_layout

\begin_layout Section
详细设计
\end_layout

\begin_layout Standard
原作者在开发本项目时，参考了很多cocos2dx的设计模式，但是有些应用的不彻底，不合理，我会对应进行改进。另外在编码规范作者也有不少应用不合理的地方，我在项目
中一一进行了更正。最后在软件架构的设计，作者的设计其实是比较混乱的，我进行了几次大改，但核心理念不变，比如仍旧使用文件存储数据（格式包含XML、json等）、仍
旧使用单例模式存储游戏运行过程中所需和产生的数据。
\end_layout

\begin_layout Subsection
功能说明
\end_layout

\begin_layout Standard
以下是我改写后的项目功能说明，由于改写主要集中在基础类上（位于文件夹Based下），因此会详细介绍部分基础类的功能，并给出与LZ项目不同之处。其他文件夹，即文件
夹Plants、Scenes和Zombies，其下的类只有小幅删减而没有大的改动，因此参照
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:LZ项目功能说明"
plural "false"
caps "false"
noprefix "false"

\end_inset

节即可。
\end_layout

\begin_layout Subsubsection
文件夹Based
\end_layout

\begin_layout Standard
该文件夹下的类都是基础类，为上层的游戏界面类提供各种功能，包括读写数据，定义接口。
\end_layout

\begin_layout Paragraph
文件夹GameData
\end_layout

\begin_layout Standard
该文件夹下的类都处理游戏相关数据。
\end_layout

\begin_layout Subparagraph
类GameData
\end_layout

\begin_layout Standard
保存游戏运行相关数据，如关卡数据，游戏素材路径，游戏交互文本。从LZ项目中的类UserInformation分离出来的类。
\end_layout

\begin_layout Standard
友元是LevelDataHandler类，该类可以访问本类所有私有成员。
\end_layout

\begin_layout Subparagraph
类LevelData
\end_layout

\begin_layout Standard
存放关卡数据，如僵尸数量，僵尸出现的频率，通关后奖励的金币数。相比LZ项目中的类LevelData，将readLevelData方法转移到类LevelDataH
andler中。
\end_layout

\begin_layout Subparagraph
类LevelDataHandler
\end_layout

\begin_layout Standard
采用单例模式，用于读写关卡数据。将LZ项目的OpenLevelData类更名为该类，使语义更加明确。
\end_layout

\begin_layout Subparagraph
类ResourcePath
\end_layout

\begin_layout Standard
存放游戏素材路径，可以自行从XML文件读取路径并初始化。
\end_layout

\begin_layout Paragraph
文件夹UserData
\end_layout

\begin_layout Subparagraph
类CaveFile
\end_layout

\begin_layout Standard
存放用户存档和默认存档的相关参数。
\end_layout

\begin_layout Subparagraph
类UserData
\end_layout

\begin_layout Standard
保存用户相关数据，如用户设置状态，用户存档参数，用户世界数据等。从LZ项目中的类UserInformation分离出来的另一个类，和GameData合并后是类U
serInformation。
\end_layout

\begin_layout Subparagraph
类UserDataHandler
\end_layout

\begin_layout Standard
采用单例模式，用于读写和用户相关的数据（包括用户独有的关卡数据，如累计获得金币数，关卡进度）。将LZ项目的UserData类更名为该类，使语义更加明确。
\end_layout

\begin_layout Subparagraph
类UserSelectCard
\end_layout

\begin_layout Standard
用户选择的植物卡片编号。
\end_layout

\begin_layout Subparagraph
类UserSetting
\end_layout

\begin_layout Standard
存放用户设置的状态还有实时音量。
\end_layout

\begin_layout Subparagraph
类UserWorldData
\end_layout

\begin_layout Standard
存放用户在关卡中需要用到的数据，通关情况等。
\end_layout

\begin_layout Paragraph
类AppDelegate
\end_layout

\begin_layout Standard
cocos2dx自动生成的类，该类用于启动游戏，我对该类进行了一点点修改，改动包括将设计分辨率修改为1920*1080。
\end_layout

\begin_layout Paragraph
类DataLoader
\end_layout

\begin_layout Standard
用于在启动游戏时加载用户和游戏数据。使用方式是在类AppDelegate的定义DataLoader对象，调用默认构造函数的同时就完成了数据的加载工作。
\end_layout

\begin_layout Paragraph
类Runtime
\end_layout

\begin_layout Standard
采用单例模式，用于保存运行时的游戏和用户数据，便于展示游戏界面的类随时访问，该类还具有检测游戏环境的功能。
\end_layout

\begin_layout Standard
使用方式是在文件夹proj.linux的main.cpp的main方法中定义Runtime对象，定义后将会把此对象的this指针装载到静态指针成员中，当退出main
函数的作用域时，静态指针也就是this指针将会被自动析构。
\end_layout

\begin_layout Subsubsection
文件夹Helper
\end_layout

\begin_layout Paragraph
类Decryptor
\end_layout

\begin_layout Standard
LZ项目中对Resource/resources/Text文件夹下的部分文件进行了加密，格式一般为.reanim.compiled，需要使用项目中的代码解密。这里我
提取了LZ项目中类UserData和类OpenLevelData的解密函数加入到该类当中用于解密，解密后的文件我都保存到原路径下，名称不变（格式遵从解密后的内容
）。
\end_layout

\begin_layout Subsection
内存管理
\end_layout

\begin_layout Subsubsection
单例模式
\end_layout

\begin_layout Standard
对于单例模式的内存管理方式参考了两种类型，设计单例类时需要根据不同的情况进行选择：
\end_layout

\begin_layout Itemize
一种是cocos2dx中UserDefault和FileUtils类的单例模式，这种单例模式获取时创建静态实例，使用完需要手动释放静态实例。注意在定义这种单例模
式时，构造函数和析构函数都要定义为
\series bold
私有的或保护的
\series default
（如果该类需要被继承），避免手动实例化的情况出现。
\end_layout

\begin_layout Itemize
还有一种是cocos2dx中Application类（定义于CCApplication-linux.h/.cpp）的单例模式，这种单例模式需要定义普通实例，使用时通
过getInstance方法获取静态实例（其中就是普通实例，两者保持一致）。使用完无需手动释放，普通实例离开其所在作用域后，自动释放其中的静态实例。注意这种单例
模式需要将构造函数定义为
\series bold
公有的
\series default
，否则定义实例时不能直接访问。
\end_layout

\begin_layout Itemize
老师在options库使用的单例模式，分别定义了实例类和单例类，和上一种模式的区别是无需手动释放创建的实例，只需把静态实例的指针置空即可。
\end_layout

\begin_layout Subsubsection
cocos2dx的内存管理
\end_layout

\begin_layout Standard
https://cloud.tencent.com/developer/article/1777104，在“使用const char*和std::string”一节
解释了哪些情况下需要释放对象。
\end_layout

\begin_layout Standard
https://forum.cocos.org/t/cocos2d-3-2/14229，cocos2d-x3.2要不要手动删除指针的。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
cocos2dx自带内存管理的功能，和其相关的对象如果是库函数创建的，而不是new创建的，就不用通过delete释放。
\end_layout

\begin_layout Subsection
游戏数据（含用户数据）
\end_layout

\begin_layout Subsubsection
用户数据
\end_layout

\begin_layout Paragraph
垂直同步
\end_layout

\begin_layout Standard
垂直同步 (VSync) 将游戏或应用程序的图像帧速率与显示监视器的刷新速率进行同步，有助于建立稳定性。如果不同步，则可能会导致画面撕裂，即图像看起来在整个屏幕
上呈现水平方向毛刺或重影的效果。
\end_layout

\begin_layout Standard
https://www.intel.cn/content/www/cn/zh/support/articles/000005552/graphics.html，英特尔
介绍垂直同步技术。
\end_layout

\begin_layout Paragraph
音效和背景音乐的区别
\end_layout

\begin_layout Standard
背景音乐是各种音乐的一种，而音效是所有音乐大小的基础，不指代某个特定的音乐大小。
\end_layout

\begin_layout Standard
对于音乐的设置，需要重启游戏，才能让设置生效，但其他的设置都能得到实时反馈。此处的优化暂不考虑，仅使用作者之前的代码。
\end_layout

\begin_layout Paragraph
用户设置读写 
\begin_inset CommandInset label
LatexCommand label
name "par:用户设置读写"

\end_inset


\end_layout

\begin_layout Standard
https://blog.csdn.net/Xiejingfa/article/details/50580793，直接看对UserDeafult的类总结即可。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
主要的用户设置通过cocos2dx的UserDefault类保存，保存的原理是对UserDefault.xml文件的读写。此处将UserDefault.xml存放在
/home/gx/.config/pvz文件夹下，该路径实际上是cocos2dx的FileUtils实例的getWritablePath()方法获取的。
\end_layout

\begin_layout Paragraph
FPS
\end_layout

\begin_layout Standard
根据机器的不同，帧率会有所变化，但是默认帧率一般在30fps之间，而高帧率在60fps之间。
\end_layout

\begin_layout Subsubsection
游戏数据
\end_layout

\begin_layout Paragraph
分辨率
\end_layout

\begin_layout Standard
分辨率必须设定为1920*1080，否则图片缩放会失常。调整分辨率需要在Based/AppDelegate下完成，添加下述代码。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

static cocos2d::Size designResolutionSize = cocos2d::Size(1920, 1080);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
暂不存储和设置部分用户和游戏数据
\end_layout

\begin_layout Standard
像是"ISBEGINSHOWEGGS"，"USEPLANTSNUMBERS"，"BREAKTHROUGH"的用户数据暂不设置和存储，看起来意义不大。
\end_layout

\begin_layout Standard
以下游戏数据也不保留，都是些次要功能。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

bool _isEncryption;                                    /* 是否加密 */
\end_layout

\begin_layout Plain Layout

bool _zombiesIsVisible;                                /* 僵尸是否隐身 */
\end_layout

\begin_layout Plain Layout

bool _zombiesIsSmall;                                  /* 是否是小僵尸 */
\end_layout

\begin_layout Plain Layout

bool _zombiesIsBig;                                    /* 是否是巨人僵尸 */
\end_layout

\begin_layout Plain Layout

bool _isNoPlants;                                      /* 是否不可种植 */
\end_layout

\begin_layout Plain Layout

int _flowerPosition;                                   /* 花坛位置 */
\end_layout

\begin_layout Plain Layout

int _usePlantsNumbers;                                 /* 使用植物数量 */
\end_layout

\begin_layout Plain Layout

float _userLose;                                       /* 玩家失败 */
\end_layout

\begin_layout Plain Layout

vector<MyPoint> _noPlantsPosition;                     /* 不可以种植的地方 */
\end_layout

\begin_layout Plain Layout

vector<int> _gameType;                                 /* 游戏类型 */
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
UML图约定
\end_layout

\begin_layout Standard
UML图中我设计的基础类将详细绘制属性、方法和可达性，而LZ项目中更改较少的类将不再详细绘制，仅仅给出类名。
\end_layout

\begin_layout Standard
由于staruml自身的原因，属性的详细类型（如是否为const，模板参数）将被忽略，析构函数将被忽略（其访问属性保证和构造函数相同）。
\end_layout

\begin_layout Standard
为了控制UML图的规模，枚举类和规模很小的类不进行绘制。
\end_layout

\begin_layout Subsection
编码规范
\end_layout

\begin_layout Standard
https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming
/，Google编码规范，尚未采用。
\end_layout

\begin_layout Standard
https://blog.csdn.net/K346K346/article/details/81395342，C++命名方式建议，有些值得参考的地方。
\end_layout

\begin_layout Subsubsection
驼峰命名
\end_layout

\begin_layout Standard
https://www.zhihu.com/question/465049546，为什么c/cpp语言的函数好像没有按照驼峰命名法呢？
\end_layout

\begin_layout Standard
https://www.ruanyifeng.com/blog/2017/02/filename-should-be-lowercase.html，为什么文件名要小写
？
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
历史原因，C/C++的早期代码往往全部小写，并且大量使用缩写，这对于项目的维护不太方便。我采用Java中广泛应用的驼峰书写，而对于类名上也和Java保持一致，类
名即文件名，提高辨识度。老师在开发彭水项目时，使用的也是这种命名规范，因此准备沿用下去。
\end_layout

\begin_layout Standard
另外英文单词能拼写全尽量拼写全，长点没关系，不要使用缩写，要不会提高别人理解代码的难度。
\end_layout

\begin_layout Subsubsection
成员变量前加下划线
\end_layout

\begin_layout Standard
https://cloud.tencent.com/developer/article/1805416，C++变量前面加下划线的含义。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
cocos2dx类中的私有成员变量前都加上了下划线，遵从了Obejective-C实例变量定义的风格。暂不评论这种风格应用在C++中的好坏，为了减少迁移代码的工
作量，决定所有
\series bold
私有
\series default
成员变量前也都加上下划线（公有成员变量不受影响），和coco2dx的编程风格保持一致。需要指出，Alt+Enter生成Getter和Setter方法时不会受前置
下划线影响。
\end_layout

\begin_layout Subsubsection
不使用全局变量
\end_layout

\begin_layout Standard
https://zhuanlan.zhihu.com/p/59636541，使用全局变量会带来诸多问题。
\end_layout

\begin_layout Subsubsection
=default的使用
\end_layout

\begin_layout Standard
由于构造函数的实现往往在.cpp文件中，其中使用了初始化参数列表。但是初始化参数列表在头文件的构造函数声明中不会体现，因此决定使用=default关键字区别默认实
现和其他实现。
\end_layout

\begin_layout Subsubsection
尖括号与双引号包含区别
\end_layout

\begin_layout Standard
为了和我编写的代码文件区别开来，游戏库文件和系统库文件统一使用尖括号包含，而我编写的代码文件使用双引号包含，如下所示。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#include <cocos2d.h>
\end_layout

\begin_layout Plain Layout

#include <ui/CocosGUI.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#include <map>
\end_layout

\begin_layout Plain Layout

#include <string>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#include "Based/Runtime.h"
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
单入单出
\end_layout

\begin_layout Standard
按照编码规范，函数应该只有一处返回值，如果有多种（或多个）返回值，可以考虑使用枚举或者结构体封装。LZ项目中许多代码虽然使用了枚举封装，但是返回值的地方有多处，
不符合单入单出的规范，由于涉及代码数量过多因此不做更改。
\end_layout

\begin_layout Subsubsection
switch中部分case使用花括号包裹
\end_layout

\begin_layout Standard
https://stackoverflow.com/questions/61708267/jump-bypasses-variable-initializatio
n-in-switch-statement，Jump bypasses variable initialization in switch statement。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
switch中某个case下如果定义变量或者符号应使用花括号包裹，可以把作用域控制在当前case下，而不会影响之后的case。
\end_layout

\begin_layout Subsubsection
函数重载和函数模板
\end_layout

\begin_layout Standard
函数重载主要针对参数个数不同的情况，而函数模板针对参数类型不同，但个数相同的情况。相比之下，函数模板更具有广泛性。另外函数模板可以重载，但是类模板不能重载。
\end_layout

\begin_layout Subsubsection
getter和setter方法的约定
\end_layout

\begin_layout Standard
get方法一般仅用来获取值，不用来更改值，因此返回变量的拷贝，不返回引用。但是有时需要返回对象成员并对其下特定成员进行更改，这时需要返回该对象引用。
\end_layout

\begin_layout Subsubsection
类的成员变量应该使用引用类型、指针类型还是对应类型对象
\end_layout

\begin_layout Standard
https://blog.csdn.net/bumingchun/article/details/112755993，简洁的给出该问题的定义和结论，一般没有特殊需求
，成员定义为对应类型对象是最好的。
\end_layout

\begin_layout Subsubsection
结构体和类的选择
\end_layout

\begin_layout Standard
如果某对象仅组合在其他的类中作为成员，有getter和setter方法的接口，那么该对象的类定义为结构体即可。无需层层封装getter和setter接口。
\end_layout

\begin_layout Subsubsection
枚举名约定
\end_layout

\begin_layout Standard
https://blog.csdn.net/craftsman1970/article/details/106026360，不使用全部大写的枚举名。
\end_layout

\begin_layout Standard
为了避免不必要的编码错误，不使用汉字作为枚举名。为了避免和宏冲突，不使用全部大写的枚举名。此处使用首字母大写，其他字母小写的枚举名。
\end_layout

\begin_layout Subsubsection
.cpp需要的头文件要转移到.h文件中吗
\end_layout

\begin_layout Standard
不需要。#include尽量写到cpp文件里，因为两个文件在.h文件里相互include，就会产生编译错误，而两个文件在.h文件互相include，就不会有该问题，
因此在.h文件include就要避免互相包含的问题，而.cpp文件就不需要考虑。
\end_layout

\begin_layout Subsection
使用C++17标准
\end_layout

\begin_layout Standard
/home/gx/Documents/pvz/pvz/cocos2d/cmake/Modules/CocosConfigDefine.cmake，其中定义了coc
os2d项目使用的C++标准，默认为11，这里我尝试改成了C++17，可以运行，所以就用C++17，享受更多语法特性带来的便利。注意：仅仅在顶层CMakeLis
ts.txt的更改C++标准是不够的。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# check c++ standard
\end_layout

\begin_layout Plain Layout

set(CMAKE_C_STANDARD 99)
\end_layout

\begin_layout Plain Layout

set(CMAKE_C_STANDARD_REQUIRED ON)
\end_layout

\begin_layout Plain Layout

set(CMAKE_CXX_STANDARD 17)
\end_layout

\begin_layout Plain Layout

set(CMAKE_CXX_STANDARD_REQUIRED ON)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
https://stackoverflow.com/questions/67432538/cannot-set-cmake-warn-deprecated-ins
ide-the-cmakelists-txt，使用CMake命令消除deprecated warnings。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
更改为C++17标准后，第一次构建整个项目时会出现了大量的deprecated warnings，如下所示。但是之后不会反复弹出，所以暂不考虑设定特别的CMak
e选项去消除它。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

warning: ‘template<class _Category, class _Tp, class _Distance, class _Pointer,
 class _Reference> struct std::iterator’ is deprecated [-Wdeprecated-declaration
s]
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
部分问题解决方案
\end_layout

\begin_layout Subsubsection
语法相关问题
\end_layout

\begin_layout Standard
本节记录项目相关的部分语法问题，还有一部分语法问题的解决方案已经迁移到C++专题笔记下。
\end_layout

\begin_layout Paragraph
non-const lvalue reference type _normal_iterator<> cannot bind a temporary
 of type _normal iterator in gcc
\end_layout

\begin_layout Standard
https://stackoverflow.com/questions/58867984/non-const-lvalue-reference-type-norm
al-iterator-cannot-bind-a-temporary-of-ty
\end_layout

\begin_layout Paragraph
warning: object backing the pointer will be destroyed at the end of the
 full-expression for std::pair
\end_layout

\begin_layout Standard
https://stackoverflow.com/questions/64657316/warning-object-backing-the-pointer-w
ill-be-destroyed-at-the-end-of-the-full-exp
\end_layout

\begin_layout Paragraph
libfmod.so: .dynsym local symbol at index 2 (>= sh_info of 2)
\end_layout

\begin_layout Standard
暂时使用在CMakeLists.txt中添加-fuse-ld=gold解决，但是还是不管用。
\end_layout

\begin_layout Standard
https://stackoverflow.com/questions/59915966/unknown-gcc-linker-error-but-builds-
sucessfully，提出使用-fuse-ld=gold选项，但是貌似不管用。
\end_layout

\begin_layout Paragraph
ISO C++11 does not allow conversion from string literal to 'char *'
\end_layout

\begin_layout Standard
将转换的目标变量设置为const char*类型即可。
\end_layout

\begin_layout Paragraph
Cannot initialize object parameter of type 'cocos2d::Ref' with an expression
 of type 'MainMenu'
\end_layout

\begin_layout Standard
在MainMenu中，由于使用到的ui类型定义没有覆盖全，只需包含所需头文件即可解决此类问题。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#include <ui/CocosGUI.h>
\end_layout

\begin_layout Plain Layout

using namespace cocos2d::ui;
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Non-const lvalue reference to type 'cocos2d::Vec2' cannot bind to a temporary
 of type 'cocos2d::Vec2'
\end_layout

\begin_layout Standard
https://blog.csdn.net/jokerMingge/article/details/121554826，“非常量引用的初始值必须为左值“及“匿名对象
“。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
诸如此类问题其实是匿名对象导致的，因为匿名对象是prvalue(纯右值)，无法作为引用传递，若想引用参数接收匿名对象只有用reference-to-const接
收。当一个对象被用作右值时，用的是对象的值，当对象被用作左值的时候，用的是对象的身份。而引用只能引用身份，不能引用纯值（如匿名对象）。
\end_layout

\begin_layout Paragraph
delete野指针
\end_layout

\begin_layout Standard
https://www.zhihu.com/question/38998078，C++ 里 delete 指针两次会怎么样？
\end_layout

\begin_layout Standard
另外需要指出，delete一个指针之后，只是回收该指针指向的堆空间，而指针本身的值不变（也就是说delete并不将指针删除，同时指针仍然指向原来的那个地址）。因
此delete后将指针置空是个好习惯，因为delete空指针是合法的，没有副作用。
\end_layout

\begin_layout Paragraph
多用户存档
\end_layout

\begin_layout Standard
https://rapidjson.org/classrapidjson_1_1_generic_document.html，GenericDocument类的官方
文档。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
暂不支持多用户存档，一个原因是这是次要功能，另外一个原因是在实现过程中发现UserDataHandler的createNewUserDataDocument()
方法，反复调用可能会出现问题，string类型和rapidJson::GenericDocument释放过程中会崩溃。
\end_layout

\begin_layout Standard
以上问题已解决，是打开和保存用户数据的方法定义不当，使用函数模板和if constexpr语法后解决了问题。
\end_layout

\begin_layout Paragraph
模板返回类型的默认值
\end_layout

\begin_layout Standard
https://stackoverflow.com/questions/38038860/default-or-zero-value-of-unknown-tem
plate-type，Default or zero value of unknown template type，给出的解决办法简单合理。
\end_layout

\begin_layout Standard
https://stackoverflow.com/questions/12615549/how-to-get-the-default-value-of-any-
type，How to get the default value of any type，讨论了多种解决办法，但是结果不太清晰。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
有模板返回类型默认值的需求，但是C++20前还没有很好实现的办法，以下是workaround。考虑到兼容和语义清晰，我选择return T()。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

template <typename T>
\end_layout

\begin_layout Plain Layout

T void fun() {
\end_layout

\begin_layout Plain Layout

	// ...
\end_layout

\begin_layout Plain Layout

	return T() or T{} or {};	// use {} since C++11
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
函数模板声明与实现分离
\end_layout

\begin_layout Standard
https://www.zhihu.com/question/535308979/answer/2512192023，最高赞回答解释的非常清晰。
\end_layout

\begin_layout Standard
https://blog.csdn.net/jslove1997/article/details/118339198，简单解释了不能分离定义的原因。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
在C++20之前不建议将函数模板声明与实现分离在不同文件中，因为语法和编译器支持尚不到位。
\end_layout

\begin_layout Paragraph
根据不同的模板参数完成对应操作
\end_layout

\begin_layout Standard
https://stackoverflow.com/questions/11021267/perform-different-methods-based-on-t
emplate-variable-type，Perform different methods based on template variable
 type，提问者重现了我的问题。
\end_layout

\begin_layout Standard
https://stackoverflow.com/questions/73330007/c-conditionally-call-functions-based
-on-type-of-the-template-parameter，提问者很好地描述了我的需求，在C++17下有解决方案。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
虽然有workaround方法，但建议使用函数重载。
\end_layout

\begin_layout Paragraph
FMOD error! (51) Error initializing output device.
\end_layout

\begin_layout Standard
https://github.com/cocos2d/cocos2d-x/issues/16627，提出两种解决方案，一种是更改AudioEngine的代码，另外
一种是安装pulseaudio，采纳了后者。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
可能是使用C++17编译导致的问题，在安装pulseaudio之后解决了，安装命令如下所示。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sudo apt install pulseaudio
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
部分错误信息如下所示。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

FMOD error! (51) Error initializing output device.
\end_layout

\begin_layout Plain Layout

FMOD error! (67) This command failed because System::init or System::setDriver
 was not called.
\end_layout

\begin_layout Plain Layout

sound effect in resources/Music/Clocks.ogg could not be preload
\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
auto并不会自动引用
\end_layout

\begin_layout Standard
https://blog.51cto.com/luweir/4875857，在std::vector<int>上测试auto需不需要加引用符。
\end_layout

\begin_layout Standard
如果auto所代表的类型需要引用的话，需要显式加上引用符&。
\end_layout

\begin_layout Paragraph
const char*和char*作为返回值的问题
\end_layout

\begin_layout Standard
https://bbs.csdn.net/topics/50246945，关于const char*和char*作返回值的讨论。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
在使用const char*之前，首先要了解const char*的含义，以及与char* const的区别，如下代码所示。
\end_layout

\begin_layout Standard
一般const char*指向的字符串所占用的内存大小都是固定的，因此修改其值有可能导致数组越界，基于此返回const char*避免指针所指向的值被意外更改。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

char* const str1 = "Hello, World"; 	//常指针，指向字符串
\end_layout

\begin_layout Plain Layout

*str1 = ''M''; 						//可以改变字符串内容
\end_layout

\begin_layout Plain Layout

str1 = "Bye, World"; 				//错误，如能改变常指针指向的内存地址
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

const char* str2 = "Hello, World"; 	//指针，指向字符串常量
\end_layout

\begin_layout Plain Layout

*str2 = ''M''; 						//错误，不能改变字符串内容
\end_layout

\begin_layout Plain Layout

str2 = "Bye, World"; 				  //修改指针使其指向另一个字符串
\end_layout

\begin_layout Plain Layout

*str2 = ''M''; 						//错误，仍不能改变字符串内容
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
对引用取地址
\end_layout

\begin_layout Standard
https://bbs.csdn.net/topics/350058236，讨论区给出了回答，引用就是别名，他们的地址一样！。
\end_layout

\begin_layout Paragraph
Lambda使用[&]捕获时要格外小心
\end_layout

\begin_layout Standard
Lambda使用[&]捕获时要格外小心，如果捕获的是基础类型值，很可能在Lambda函数执行时已经被释放了，此时再访问就相当于访问野指针，如下代码所示，之前通过
[&]捕获的ID在Lambda函数执行时已经被释放，这里更正为[=]拷贝捕获。
\end_layout

\begin_layout Standard
另外在使用引用捕获时还遇到了其他问题，尚未找出原因，建议能使用拷贝捕获就使用拷贝捕获。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

void InputDataMenu::createButtons(Sprite* sprite, const std::string& Label,
 const Vec2& vec2,
\end_layout

\begin_layout Plain Layout

                                  const float scale, const int ID) {
\end_layout

\begin_layout Plain Layout

    auto button = Button::create("button.png", "button_down.png", "", TextureResTy
pe::PLIST);
\end_layout

\begin_layout Plain Layout

    button->setPosition(vec2);
\end_layout

\begin_layout Plain Layout

    button->setScaleX(scale);
\end_layout

\begin_layout Plain Layout

    button->setTitleLabel(label(Label, 20, Vec2(0, 0), 0, Color3B::GREEN,
 1.0f / scale));
\end_layout

\begin_layout Plain Layout

    sprite->addChild(button);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    CaveFile* caveFile = &(_runtime->userData->getCaveFile());
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    button->addTouchEventListener([=](Ref* sender, Widget::TouchEventType
 type) {
\end_layout

\begin_layout Plain Layout

        switch (type) {
\end_layout

\begin_layout Plain Layout

            case Widget::TouchEventType::BEGAN: {
\end_layout

\begin_layout Plain Layout

                cocos2d::log("Widget::TouchEventType::BEGAN, ID: %d", ID);
\end_layout

\begin_layout Plain Layout

                MusicPlayer::playMusic("gravebutton");
\end_layout

\begin_layout Plain Layout

                break;
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            case Widget::TouchEventType::ENDED: {
\end_layout

\begin_layout Plain Layout

                cocos2d::log("Widget::TouchEventType::ENDED, ID: %d", ID);
\end_layout

\begin_layout Plain Layout

                switch (ID) {
\end_layout

\begin_layout Plain Layout

                    case 1: { /* 确定 */
\end_layout

\begin_layout Plain Layout

                        if (!_textField->getString().empty() &&
\end_layout

\begin_layout Plain Layout

                            _textField->getString() != "未命名存档") {
\end_layout

\begin_layout Plain Layout

                            caveData();
\end_layout

\begin_layout Plain Layout

                            updateButtonText();
\end_layout

\begin_layout Plain Layout

                            this->removeChildByName("_shieldDialogLayer");
\end_layout

\begin_layout Plain Layout

                            _inputString.clear();
\end_layout

\begin_layout Plain Layout

                        }
\end_layout

\begin_layout Plain Layout

                        break;
\end_layout

\begin_layout Plain Layout

                    }
\end_layout

\begin_layout Plain Layout

                    case 2: { /* 取消 */
\end_layout

\begin_layout Plain Layout

                        if (_runtime->userData->getUserName() != "未命名存档")
 {
\end_layout

\begin_layout Plain Layout

                            this->removeChildByName("_shieldDialogLayer");
\end_layout

\begin_layout Plain Layout

                            _inputString.clear();
\end_layout

\begin_layout Plain Layout

                        }
\end_layout

\begin_layout Plain Layout

                        break;
\end_layout

\begin_layout Plain Layout

                    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                    case 3: {
\end_layout

\begin_layout Plain Layout

                        _userDefault->setIntegerForKey("USERDATANUMBER",
\end_layout

\begin_layout Plain Layout

                                                       _caveFileNumber);
 /* 记录所选存档 */
\end_layout

\begin_layout Plain Layout

                        caveFile->userCaveFileNumber = _caveFileNumber;
\end_layout

\begin_layout Plain Layout

                        UserDataHandler::getInstance()->createNewUserDataDocumen
t();
\end_layout

\begin_layout Plain Layout

                        DataLoader::loadUserFileData();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                        const int id = caveFile->userCaveFileNumber;
\end_layout

\begin_layout Plain Layout

                        const char* key = caveFile->userCaveFileNameKey[id].c_str
();
\end_layout

\begin_layout Plain Layout

                        string str = _userDefault->getStringForKey(key);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                        /* 读取所选存档的名字并更新 */
\end_layout

\begin_layout Plain Layout

                        if (!str.empty()) {
\end_layout

\begin_layout Plain Layout

                            _runtime->userData->setUserName(str);
\end_layout

\begin_layout Plain Layout

                        } else {
\end_layout

\begin_layout Plain Layout

                            auto userCaveFileName = caveFile->userCaveFileName;
\end_layout

\begin_layout Plain Layout

                            string userName = userCaveFileName[_caveFileNumber];
\end_layout

\begin_layout Plain Layout

                            _runtime->userData->setUserName(userName);
\end_layout

\begin_layout Plain Layout

                        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                        _runtime->userData->setIsUpdate(true);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                        deleteDialog();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                        Director::getInstance()->replaceScene(MainMenu::create()
);
\end_layout

\begin_layout Plain Layout

                        break;
\end_layout

\begin_layout Plain Layout

                    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                    case 4: deleteDialog(); break;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                    case 5: createShieldLayer(); break;
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            default: {
\end_layout

\begin_layout Plain Layout

                cocos2d::log("Enumeration values 'MOVED' and 'CANCELED'
 not handled in switch: "
\end_layout

\begin_layout Plain Layout

                             "InputDataMenu::createButtons");
\end_layout

\begin_layout Plain Layout

                break;
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    });
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
野指针
\end_layout

\begin_layout Standard
迁移项目时注意野指针问题，要在构造函数或者其他位置对指针赋值或者置空。
\end_layout

\begin_layout Paragraph
在派生类的构造函数中初始化基类成员
\end_layout

\begin_layout Standard
派生类的构造函数的初始化列表可以包含基类的构造函数、派生类成员的初始化，但是不能有基类成员的初始化！但是可以在派生类构造函数体中初始化基类成员，但是不建议这么做
。派生类构造函数一般形式如下。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

派生类构造函数名(总参数表列): 基类构造函数名(参数表列)，子对象名(参数表列)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

        派生类中新增数成员据成员初始化语句
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
本项目仍旧选择在派生类构造函数体中初始化基类成员，仅仅是为了方便和直观，后续考虑按照上述一般形式调整。
\end_layout

\begin_layout Subsubsection
IDE相关问题
\end_layout

\begin_layout Paragraph
rename symbol under cursor不可靠
\end_layout

\begin_layout Standard
使用该功能，有时会改出多余的符号，这时需要手动排查。
\end_layout

\begin_layout Subsubsection
系统相关问题
\end_layout

\begin_layout Paragraph
垂直同步
\end_layout

\begin_layout Standard
https://stackoverflow.com/questions/62023435/do-you-have-to-call-glfwswapinterval
1-in-an-opengl-program，Do you have to call glfwSwapInterval(1) in an OpenGL
 program?
\end_layout

\begin_layout Standard
将wglSwapIntervalEXT替换为glfwSwapInterval似乎能达到同样的目的。
\end_layout

\begin_layout Paragraph
同时播放音乐数量的限制
\end_layout

\begin_layout Standard
https://github.com/cocos2d/cocos2d-x/issues/17151，Linux下播放音乐超出限制后无法再播放新的音乐，目前在coc
os2dx的3.15版本还没有修复。
\end_layout

\begin_layout Standard
https://discuss.cocos2d-x.org/t/fail-to-play-cause-by-limited-max-instance-of-audi
oengine/26800/6，不建议使用setMaxAudioInstance来突破音乐播放数量的限制，一种解决办法是手动移除历史播放的音乐，但是非常麻烦。
\end_layout

\begin_layout Paragraph
新增游戏音乐
\end_layout

\begin_layout Standard
https://convertio.co/zh/mp3-ogg/，mp3转换为ogg格式。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
如果在resources/Music下新增了音乐文件，需要将路径添加到resources/Text/MusicPath.xml下，代码如下所示。为了触发Music
Path.xml的重新加载，需要将存放用户数据的文件夹删除，路径为/home/用户名/.config/pvz，参见
\begin_inset CommandInset ref
LatexCommand ref
reference "par:用户设置读写"
plural "false"
caps "false"
noprefix "false"

\end_inset

节。
\end_layout

\begin_layout Standard
最后音乐格式需要转换为ogg格式。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<p secretlabs="resources/Music/secretlabs.ogg"/>
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
基于apache license 2.0项目二次开发后再开源
\end_layout

\begin_layout Standard
https://github.com/ErLinErYi/PlantsVsZombies/blob/master/LICENSE，LZ项目采用协议的英文介绍。
\end_layout

\begin_layout Standard
https://choosealicense.com/，Github官方提供选择协议的指导。
\end_layout

\begin_layout Standard
https://www.v2ex.com/t/881326，指出代码声明里保持他们的声明就可以，不要用他们的商标宣传。
\end_layout

\begin_layout Standard
https://segmentfault.com/a/1190000022973105，当使用声明了 Apache License Version
 2.0 的软件时，需要有显著的声明，不得有隐瞒和可以忽略的色彩。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
LZ项目采用的是apache license 2.0，我基于LZ项目二次开发再开源需要遵循该协议。
\end_layout

\begin_layout Section
LZ项目配置
\end_layout

\begin_layout Standard
LZ项目——在本文档指代ErLinErYi开发的植物大战僵尸项目，以下是GitHub项目和资源文件下载路径。
\end_layout

\begin_layout Standard
https://github.com/ErLinErYi/PlantsVsZombies，学习项目地址。 
\end_layout

\begin_layout Standard
https://caiyun.139.com/m/i?135ClQmyJEXz2，该项目资源文件下载。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
由于LZ项目是使用Visual Studio搭建的，因此准备在VS下搭建并学习源码，再迁移到Linux开发。
\end_layout

\begin_layout Standard
该项目执行ISO C++14标准，在Windows下开发，之前尝试在Linux下搭建，尚未成功。
\end_layout

\begin_layout Subsection
IDE
\end_layout

\begin_layout Subsubsection
Visual Studio
\end_layout

\begin_layout Standard
经过尝试，成功在Visual Studio 2019和Visual Studio 2017（vs2019）下搭建该项目。
\end_layout

\begin_layout Standard
在Visual Studio 2017下，如果Windows SDK Version配置不正确的话，会报编译器内部错误（An internal
 error has occurred in the compiler）。
\end_layout

\begin_layout Standard
在Visual Studio 2019下，编译时出现宏CC_FORMAT_PRINTF未定义的问题，位于libcocos2d下的CCPlatformMacros.
h，表面的原因是代码本身的逻辑判断跳过了对CC_FORMAT_PRINTF的定义，但实际上还和工具链有关，该问题尚未发现不利影响。
\end_layout

\begin_layout Standard
在Visual Studio 2020下编译报标识符不允许中文问题（this character is not allowed in an identifier
），在此之前由于中文乱码，将项目文件全部转码为UTF-8，怀疑是此项操作导致的问题，后续未尝试。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
https://visualstudio.microsoft.com/zh-hans/vs/older-downloads/，下载vs2017企业版，版本15.9（激
活前可以试用30天）。
\end_layout

\begin_layout Standard
安装时选中Desktop development with C++，采用默认选项的同时，注意增加选项Windows 8.1 SDK。
\end_layout

\begin_layout Standard
克隆LZ项目，将资源文件放置在指定目录，然后使用vs2017打开根目录下的PlantsVsZombies.sln。
\end_layout

\begin_layout Paragraph
VS配置
\end_layout

\begin_layout Standard
将Solution Platforms设置为x86。
\end_layout

\begin_layout Standard
右击PlantsVsZombies、libSpine子项目，点击Properties打开，将Platform Toolset设置为v141，Windows
 SDK Version设置为10.0.17763.0（或其他10.0的SDK）。
\end_layout

\begin_layout Standard
右击librecast、libcocos2d、libbox2d，点击Properties打开，将Platform Toolset设置为v141，Windows
 SDK Version设置为8.1。
\end_layout

\begin_layout Paragraph
缺少MSVCR110.dll
\end_layout

\begin_layout Standard
通过安装x86版本的Visual C++ Redistributable for Visual Studio 2012解决问题。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
https://www.microsoft.com/zh-CN/download/details.aspx?id=30679，Visual C++ Redistrib
utable for Visual Studio 2012下载地址。
\end_layout

\begin_layout Standard
https://www.drivereasy.com/knowledge/how-to-fix-msvcr110-dll-is-missing/，给出5种解决方案，
依次递进。
\end_layout

\begin_layout Standard
https://blog.csdn.net/lemonisan/article/details/109146494，来自中文社区，给出三步解决方案，依次递进。
\end_layout

\begin_layout Paragraph
修改语言包（显示语言）
\end_layout

\begin_layout Standard
我更习惯用英文，修改方法参见：https://blog.csdn.net/Bob__yuan/article/details/106317351。
\end_layout

\begin_layout Paragraph
Debug信息格式设置（Error C3130）
\end_layout

\begin_layout Standard
https://discuss.cocos2d-x.org/t/failed-to-write-injected-code-block-to-pdb/12519/1
2，讨论的最后给出了解决方案。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
使用Debug模式编译项目时出现Error C3130 Internal Compiler Error: failed to write injected
 code block to PDB。
\end_layout

\begin_layout Standard
Project->Properties->Configuration Properties->C/C++->General->Debug information
 format->C7 compatible(/Z7)
\end_layout

\begin_layout Subsection
中文乱码
\end_layout

\begin_layout Standard
通过Visual Studio 2019启动似乎解决了乱码问题，但还是要说明下乱码原因，源码文件大部分以GBK（即GB2312）编码，而从Visual
 Studio 2022打开时按UTF-8解码，所以出现了乱码。
\end_layout

\begin_layout Standard
解决乱码的办法可以通过转码完成，不过在项目中引入了新的问题，因此不建议采用。
\end_layout

\begin_layout Standard
在Windows平台下我找到软件CodeTramit可以实现批量转码，使用方便，下载地址：https://blog.csdn.net/dpsying/article
/details/118553524。
\end_layout

\begin_layout Standard
也可以直接使用Visual Studio修改当前页面编码（不能批量处理），参见：https://blog.csdn.net/weixin_42109012/arti
cle/details/95747576。
\end_layout

\begin_layout Standard
在Linux平台下考虑使用iconv完成文本内容的转码，不过该命令（iconv）一次只能转码一个文件，需要配合Shell脚本批量读入。
\end_layout

\begin_layout Subsection
代码风格
\end_layout

\begin_layout Subsubsection
宏__MAIN_H__
\end_layout

\begin_layout Standard
宏__MAIN_H__在main.h中使用，LZ项目中的main.h对应PlantsVsZombies.h。
\end_layout

\begin_layout Standard
https://bbs.csdn.net/topics/250073215，main.h的用法。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
main.h可以作为一个公共的头文件，包含一些公共头文件，声明一些自定义数据类型，自定义常量什么的，这些信息放在各自c文件的头文件中也不太合适，可以在main.h中
声明。 当然，也不是一定必须的，也可以写一个专门定义常量、类型的头文件之类的。这样做，总览的逻辑关系清晰一点。 
\end_layout

\begin_layout Subsection
多媒体文件
\end_layout

\begin_layout Subsubsection
动画文件
\end_layout

\begin_layout Standard
目前给出的资源文件中的动画文件是编译过的。
\end_layout

\begin_layout Standard
https://plantsvszombies.fandom.com/wiki/Modify_Plants_vs._Zombies，动画文件的修改。
\end_layout

\begin_layout Standard
https://www.bilibili.com/read/cv5476547/，以向日葵的动画修改为例。
\end_layout

\begin_layout Standard
https://plantsvszombies.fandom.com/f/p/3418359504830875373，提供了PVZUtil 1.0提取.reanim.co
mpiled格式的动画文件，但是不适用于.reanim.compiled格式的xml文件的提取。
\end_layout

\begin_layout Subsubsection
精灵图集
\end_layout

\begin_layout Standard
一个cocos2dx的精灵图集由后缀.plist和.pvr.ccz构成，其中plist文件指明了图集中每张图片的名字和在图集中的位置，pvr.ccz文件是对应的图集，可
以使用TexturePacker预览，也可以使用该软件另存为.png格式的图片。目前尚没有找到一个软件可以实时预览图集中每张图片的名字和区域，不过可以使用脚本将图
集中每张图片中提取出来，从而得知每张图片对应的名字。
\end_layout

\begin_layout Standard
https://github.com/song0071000/UnpackPlistPng，提取图集中图片的脚本，安装限制多。
\end_layout

\begin_layout Standard
https://github.com/onepill/texture_unpacker_scirpt，提取Texture制作图集中的图片，兼容性好。
\end_layout

\begin_layout Standard
https://blog.csdn.net/baidu20008/article/details/41445963，提取plist文件中的单图或分解plist大图为
小图。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
此处选用texture_unpacker_scirpt，在Windows平台的配置步骤如下，先安装Python3.10，再安装Pillow，脚本如下。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

python3 -m pip install --upgrade pip
\end_layout

\begin_layout Plain Layout

python3 -m pip install --upgrade Pillow
\end_layout

\end_inset


\end_layout

\begin_layout Standard
克隆texture_unpacker_scirpt到指定文件夹，将要提取的图集（即.plist和.png文件）放在同一文件夹下，执行下述命令提取。
\end_layout

\begin_layout Standard
需要补充的是，.png文件是通过texturePacker打开.pvr.ccz后另存为的图片。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

python3 unpacker.py World_1
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
数据文件的加密与解密
\end_layout

\begin_layout Standard
如果增删了数据文件，那么需要对项目重新运行cmake文件进行同步，否则会报错说找不到已经删除的文件。
\end_layout

\begin_layout Subsubsection
解密
\end_layout

\begin_layout Paragraph
解密函数
\end_layout

\begin_layout Standard
LZ对XML文件的内容进行了加密，解密是通过以下代码完成的，其中textpath是加密后xml文件的路径，passWords是解密的文件内容。准备通过打印pas
sWords的方式获取原始文件内容，然后单独保存文件。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

OpenLevelData::getInstance()->decrypt(textpath, passWords);
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
输出解密后的文件
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#include <iostream> 
\end_layout

\begin_layout Plain Layout

#include <fstream>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* 解密 */
\end_layout

\begin_layout Plain Layout

decrypt(str, passWords);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

cocos2d::log("decrypt: %s", passWords);
\end_layout

\begin_layout Plain Layout

ofstream os;     //创建一个文件输出流对象
\end_layout

\begin_layout Plain Layout

os.open("C:
\backslash

\backslash
Users
\backslash

\backslash
xigon
\backslash

\backslash
Documents
\backslash

\backslash
GitHub
\backslash

\backslash
PlantsVsZombies
\backslash

\backslash
LevelData.txt");//将对象与文件关联
\end_layout

\begin_layout Plain Layout

os << string(passWords);   //将输入的内容放入txt文件
\end_layout

\begin_layout Plain Layout

os.close();
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
正在处理的加密文件
\end_layout

\begin_layout Standard
https://jsonformatter.org/xml-parser，通过xml-parser可以在线读取.reanim1.compiled格式的文件。
\end_layout

\begin_layout Standard
https://www.w3cschool.cn/tools/index?name=xmljson，在线完成xml和json的相互转换。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
resources/Text/GAMEWORLD_1DATAS.reanim.compiled
\end_layout

\begin_layout Standard
resources/Text/GAMEWORLD_1DATAS_DIF.reanim.compiled
\end_layout

\begin_layout Standard
以上两个文件都经过了加密。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
resources/Text/GAMEWORLD_1DATAS.reanim1.compiled
\end_layout

\begin_layout Standard
resources/Text/GAMEWORLD_1DATAS_DIF.reanim1.compiled
\end_layout

\begin_layout Standard
以上两个文件是解密后的文件，但仍需要XML Parser读取。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
Windows下cocos2d的SAXParser无法读取上述文件，但是也不报错，程序直接崩溃了，目前尚未修复。Linux下也无法读取上述文件，但是有报错coc
os2d: SAXParser: Error parsing xml: expected < at。
\end_layout

\begin_layout Standard
后来发现上述文件实际上是json格式，需要使用OpenLevelData类（在Based/LevelData.h下定义）中读取，其中用到了rapidjson。
\end_layout

\begin_layout Subsection
依赖
\end_layout

\begin_layout Subsubsection
Spine
\end_layout

\begin_layout Standard
Spine是一款针对游戏的 2D 骨骼动画编辑工具。 Spine旨在提供更高效和简洁的工作流程，以创建游戏所需的动画。Spine支持很多游戏工具，包括Cocos
2dx。官方的运行库可以在GitHub下载，其中许可证授权在你的游戏中可以使用运行库。并且所有的代码都是开源的，这些开源的功能在你的游戏中都是必不可少的。
\end_layout

\begin_layout Standard
https://github.com/EsotericSoftware/spine-runtimes/，官方运行库。
\end_layout

\begin_layout Subsection
Windows API
\end_layout

\begin_layout Subsubsection
使用 __declspec(dllexport) 从 DLL 导出
\end_layout

\begin_layout Standard
https://docs.microsoft.com/zh-cn/cpp/build/exporting-from-a-dll-using-declspec-dll
export?view=msvc-170，官方文献。
\end_layout

\begin_layout Standard
https://www.jianshu.com/p/ea45468f25f1，关于dllexport部分解释得不够清晰。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
__declspec(dllexport) 关键字可以从 DLL 中导出数据、函数、类或类成员函数。 __declspec(dllexport)
 将导出指令添加到对象文件中，因此你不需要使用 .def 文件。
\end_layout

\begin_layout Standard
若要导出函数，__declspec(dllexport) 关键字必须出现在调用约定关键字的左侧（如果指定了关键字的话）。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

__declspec(dllexport) void __cdecl Function1(void);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
若要导出类中的所有公共数据成员和成员函数，该关键字必须出现在类名的左侧。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class __declspec(dllexport) CExampleExport : public CObject
\end_layout

\begin_layout Plain Layout

{ ...
 class definition ...
 };
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
主函数WinMain
\end_layout

\begin_layout Standard
https://developer.aliyun.com/article/246307，主函数 main WinMain _tmain _tWinMain
 的区别。
\end_layout

\begin_layout Standard
https://docs.microsoft.com/en-us/windows/win32/learnwin32/winmain--the-application
-entry-point，官方文档。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
main是C/C++的标准入口函数名，WinMain是windows API窗体程序的入口函数，而_tWinMain是Unicode版本的wWinMain函数别
名。
\end_layout

\begin_layout Standard
<tchar.h>中有如下几行：
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#ifdef _UNICODE
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#define _tmain      wmain
\end_layout

\begin_layout Plain Layout

#define _tWinMain   wWinMain
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#else   /* ndef _UNICODE */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#define _tmain      main
\end_layout

\begin_layout Plain Layout

#define _tWinMain   WinMain
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#endif
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
函数CreateMutexW
\end_layout

\begin_layout Standard
https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createmute
xw，官方文献。
\end_layout

\begin_layout Subsubsection
宏UNREFERENCED_PARAMETER
\end_layout

\begin_layout Standard
https://stackoverflow.com/questions/17192224/using-unreferenced-parameter-macro，指
出C++17的新特性可以作为代替。
\end_layout

\begin_layout Subsubsection
函数OutputDebugString
\end_layout

\begin_layout Standard
https://cloud.tencent.com/developer/ask/sof/149656，解答OutputDebugString使用中的问题。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
适用于Visual Studio输出Debug字符串，注意不能输出std::string，而要使用std::wstring。
\end_layout

\begin_layout Standard
若要输出std::string，考虑OutputDebugStringA()。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

std::wstring line = "bla";
\end_layout

\begin_layout Plain Layout

OutputDebugString( line.c_str() );
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
DWORD
\end_layout

\begin_layout Standard
双字节类型（int代表一个字节）。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

typedef unsigned long       DWORD;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
DEVMODE
\end_layout

\begin_layout Standard
DEVMODE数据结构中包含了有关设备初始化和打印机环境的信息。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

typedef DEVMODEW DEVMODE;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

typedef struct _devicemode {
\end_layout

\begin_layout Plain Layout

  TCHAR dmDeviceName[CCHDEVICENAME]; //打印机（显示设备）名称
\end_layout

\begin_layout Plain Layout

  WORD  dmSpecVersion;
\end_layout

\begin_layout Plain Layout

  WORD  dmDriverVersion;  //驱动版本号
\end_layout

\begin_layout Plain Layout

  WORD  dmSize; //结构体大小
\end_layout

\begin_layout Plain Layout

  WORD  dmDriverExtra;
\end_layout

\begin_layout Plain Layout

  DWORD dmFields;
\end_layout

\begin_layout Plain Layout

  union {
\end_layout

\begin_layout Plain Layout

    struct {
\end_layout

\begin_layout Plain Layout

          short dmOrientation; //DMORIENT_PORTRAIT (1) 纵向 or DMORIENT_LANDSCAPE
 (2) 横向
\end_layout

\begin_layout Plain Layout

          short dmPaperSize; //打印纸张类型  常用 A3:8,A4,9 ,详见下图
\end_layout

\begin_layout Plain Layout

          short dmPaperLength; //只针对打印机， 覆盖dmPaperSize指定的纸张长度 ，单位0.1mm
\end_layout

\begin_layout Plain Layout

          short dmPaperWidth; //只针对打印机，覆盖dmPaperSize指定的纸张宽度,单位0.1mm
\end_layout

\begin_layout Plain Layout

          short dmScale; // 设置打印输出缩放因子，缩放比例为dmScale/100
\end_layout

\begin_layout Plain Layout

          short dmCopies; //设置打印份数（如果打印机支持的话）
\end_layout

\begin_layout Plain Layout

          short dmDefaultSource;// 指定打印机纸张来源，通过DC_BINS 标志调用DeviceCapabilities函数获
取打印机可用纸张来源列表
\end_layout

\begin_layout Plain Layout

          short dmPrintQuality;//指定打印机质量（分辨率）DMRES_DRAFT(-1),DMRES_LOW(-2),DMRES
_MEDIUM(-3),DMRES_HIGH(-4),指定正值，则表示设置的是DPI
\end_layout

\begin_layout Plain Layout

          };
\end_layout

\begin_layout Plain Layout

   struct {
\end_layout

\begin_layout Plain Layout

          POINTL dmPosition;
\end_layout

\begin_layout Plain Layout

          DWORD  dmDisplayOrientation;
\end_layout

\begin_layout Plain Layout

          DWORD  dmDisplayFixedOutput;
\end_layout

\begin_layout Plain Layout

          };
\end_layout

\begin_layout Plain Layout

      };
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  short dmColor; //黑白，彩色设定 DMCOLOR_MONOCHROME（1）：黑白， DMCOLOR_COLOR（2）：彩色
\end_layout

\begin_layout Plain Layout

  short dmDuplex;//单面/双面设置，DMDUP_SIMPLEX（1），单面；DMDUP_VERTICAL（2），长边装订（左侧翻页)，DMDU
P_HORIZONTAL（3），短边装订(顶端翻页）
\end_layout

\begin_layout Plain Layout

  short dmYResolution;//指定Y轴DPI，若初始化设定这个值，PrintQuality 设置值为X轴DPI
\end_layout

\begin_layout Plain Layout

  short dmTTOption;
\end_layout

\begin_layout Plain Layout

  short dmCollate;//设定打印多页时，是否整理。DMCOLLATE_TRUE（1），整理；DMCOLLATE_FALSE（0），不整理
\end_layout

\begin_layout Plain Layout

  TCHAR dmFormName[CCHFORMNAME]; //表单名称，如"Letter" or "Legal"，完整表单列表通过，EnumForms
 函数获取
\end_layout

\begin_layout Plain Layout

  WORD  dmLogPixels;
\end_layout

\begin_layout Plain Layout

  DWORD dmBitsPerPel;
\end_layout

\begin_layout Plain Layout

  DWORD dmPelsWidth;
\end_layout

\begin_layout Plain Layout

  DWORD dmPelsHeight;
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  union {
\end_layout

\begin_layout Plain Layout

    DWORD dmDisplayFlags;
\end_layout

\begin_layout Plain Layout

    DWORD dmNup;
\end_layout

\begin_layout Plain Layout

        };
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  DWORD dmDisplayFrequency;
\end_layout

\begin_layout Plain Layout

#if (WINVER >= 0x0400)
\end_layout

\begin_layout Plain Layout

  DWORD dmICMMethod;
\end_layout

\begin_layout Plain Layout

  DWORD dmICMIntent;
\end_layout

\begin_layout Plain Layout

  DWORD dmMediaType;
\end_layout

\begin_layout Plain Layout

  DWORD dmDitherType;
\end_layout

\begin_layout Plain Layout

  DWORD dmReserved1;
\end_layout

\begin_layout Plain Layout

  DWORD dmReserved2;
\end_layout

\begin_layout Plain Layout

#if (WINVER >= 0x0500) || (_WIN32_WINNT >= 0x0400)
\end_layout

\begin_layout Plain Layout

  DWORD dmPanningWidth;
\end_layout

\begin_layout Plain Layout

  DWORD dmPanningHeight;
\end_layout

\begin_layout Plain Layout

#endif 
\end_layout

\begin_layout Plain Layout

#endif 
\end_layout

\begin_layout Plain Layout

} DEVMODEW;
\end_layout

\end_inset


\end_layout

\begin_layout Section
LZ项目功能说明 
\begin_inset CommandInset label
LatexCommand label
name "sec:LZ项目功能说明"

\end_inset


\end_layout

\begin_layout Standard
在学习LZ项目过程中一个简单的记录，便于二次开发时参考。
\end_layout

\begin_layout Subsection
文件夹Based
\end_layout

\begin_layout Subsubsection
AppDelegate.h/.cpp
\end_layout

\begin_layout Standard
创建cocos2dx游戏项目默认生成的启动文件，运行游戏时将会执行applicationDidFinishLaunching()方法。
\end_layout

\begin_layout Subsubsection
Dialog.h/.cpp
\end_layout

\begin_layout Standard
定义类Dialog。定义所有对话框的接口和共有的成员变量，是一个抽象类。切换用户存档，用户设置，退出游戏等对话框都继承该类。
\end_layout

\begin_layout Subsubsection
GlobalVariable.h/.cpp
\end_layout

\begin_layout Standard
定义类Global，采用单例模式，用于保存运行游戏所需的用户数据和检查游戏运行环境。
\end_layout

\begin_layout Subsubsection
LevelData.h/.cpp
\end_layout

\begin_layout Standard
用于存储和读写关卡数据，其中定义类OpenLevelData和类LevelData。
\end_layout

\begin_layout Itemize
类OpenLevelData用于读取关卡数据，其中包含解密函数（通过简单的加减、移位、按位与操作实现，未来将移除）。
\end_layout

\begin_layout Itemize
类LevelData用于存放关卡数据。
\end_layout

\begin_layout Subsubsection
PlayMusic.h/.cpp
\end_layout

\begin_layout Standard
定义类PlayMusic，用于播放游戏音乐，其中的方法都是公有静态方法。
\end_layout

\begin_layout Subsubsection
UserData.h/.cpp
\end_layout

\begin_layout Standard
定义类UserData，用于读写用户数据，然后存储在UserInformation对象下。
\end_layout

\begin_layout Subsubsection
UserInformation.h/.cpp
\end_layout

\begin_layout Standard
定义类UserInformation，枚举类WorldName，结构体UserSelectCard和WorldData。类UserInformation用于存储
所有用户和游戏数据。
\end_layout

\begin_layout Subsection
文件夹Scenes
\end_layout

\begin_layout Subsubsection
文件夹LoadingScene
\end_layout

\begin_layout Paragraph
LoadingScene.h/.cpp
\end_layout

\begin_layout Standard
定义类LoadingScene，加载界面，但是该类还包含了加载用户和游戏数据的功能。
\end_layout

\begin_layout Subparagraph
方法openResourcesPath
\end_layout

\begin_layout Standard
打开给定路径下，包含资源文件路径的xml文件，通过读取xml文件中的路径，计算文件个数，同时将路径设置到变量中，供今后加载资源使用。其中包含字符串的加密和解密，
尚不清楚为什么要增加这一步骤。
\end_layout

\begin_layout Standard
一个例子。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<?xml version="1.0" encoding="UTF-8"?>
\end_layout

\begin_layout Plain Layout

<data>
\end_layout

\begin_layout Plain Layout

  <p PlantsText="resources/Text/PlantsText.xml"/>
\end_layout

\begin_layout Plain Layout

  <p GameText="resources/Text/GameText.xml"/>
\end_layout

\begin_layout Plain Layout

  <p GAMEWORLD_1DATAS="resources/Text/GAMEWORLD_1DATAS.reanim.compiled"/>
\end_layout

\begin_layout Plain Layout

  <p GAMEWORLD_1DATAS_DIF="resources/Text/GAMEWORLD_1DATAS_DIF.reanim.compiled"/>
\end_layout

\begin_layout Plain Layout

</data>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
通过库tinyxml2解析后（经过整理）。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Name: PlantsText, Value: resources/Text/PlantsText.xml
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Name: GameText, Value: resources/Text/GameText.xml
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Name: GAMEWORLD_1DATAS, Value: resources/Text/GAMEWORLD_1DATAS.reanim.compiled
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
文件夹MainMenuScene
\end_layout

\begin_layout Paragraph
InputDataScene.h/.cpp
\end_layout

\begin_layout Standard
定义类InputDataMenu，用于选择用户存档。
\end_layout

\begin_layout Paragraph
MainMenu.h/.cpp
\end_layout

\begin_layout Standard
定义类MainMenu。加载界面后进入的主菜单，该界面可以选择存档或者进入不同模式的游戏。
\end_layout

\begin_layout Standard
一个需要注意的地方是如何实现用户存档功能，原始信息是从XML中读取解析的，之后用户自定义的信息如何存放尚不得知。
\end_layout

\begin_layout Standard
该界面可以跳转到OptionScene（类OptionsMenu），HelpScene、QuitScene（类QuitMenu）、InputDataScene（
类InputDataMenu）。
\end_layout

\begin_layout Paragraph
OptionScene.h/.cpp
\end_layout

\begin_layout Standard
定义类OptionsMenu，用户可以通过该类创建的对话框设置音乐大小，是否全屏等。
\end_layout

\begin_layout Paragraph
QuitScene.h/.cpp
\end_layout

\begin_layout Standard
定义类QuitMenu，退出游戏的对话框。
\end_layout

\begin_layout Subsubsection
文件夹HelpScene
\end_layout

\begin_layout Paragraph
HelpScene.h/.cpp
\end_layout

\begin_layout Standard
定义类HelpScene，展示本项目相关信息。
\end_layout

\begin_layout Subsubsection
文件夹WorldScene
\end_layout

\begin_layout Paragraph
World_1.h/.cpp
\end_layout

\begin_layout Standard
定义类World_1。现代世界关卡。选择关卡后，进入选择植物界面，即类SelectPlantsScene。
\end_layout

\begin_layout Subparagraph
_caveFileNumber
\end_layout

\begin_layout Standard
用户文档编号，是全局唯一的，默认从0开始计数。
\end_layout

\begin_layout Subparagraph
readWorldLevel()
\end_layout

\begin_layout Standard
读取关卡数据信息。
\end_layout

\begin_layout Subparagraph
GAMEWORLD_1DATAS_DIF
\end_layout

\begin_layout Standard
噩梦模式关卡数据
\end_layout

\begin_layout Subparagraph
GAMEWORLD_1DATAS
\end_layout

\begin_layout Standard
简单模式关卡数据
\end_layout

\begin_layout Paragraph
SelectWorldScene.h/.cpp
\end_layout

\begin_layout Standard
定义类SelectWorldScene，用于选择世界，比如现代世界，暗黑时代。
\end_layout

\begin_layout Standard
简单起见，只保留现代世界，而该类即将被移除。
\end_layout

\begin_layout Subsubsection
文件夹GameScene
\end_layout

\begin_layout Paragraph
GSBackgroundLayer.h/.cpp
\end_layout

\begin_layout Standard
定义类GSBackgroundLayer，进入关卡后设置背景。
\end_layout

\begin_layout Paragraph
OpenCaveGameScene.h/.cpp
\end_layout

\begin_layout Standard
定义类OpenCaveGameScene，如果之前保存游戏进度的话，则会读取并回到暂停场景，即当前场景。
\end_layout

\begin_layout Standard
简单起见，准备废弃该类，不保存游戏运行暂停的数据。
\end_layout

\begin_layout Paragraph
GSAnimationLayer.h/.cpp
\end_layout

\begin_layout Standard
定义类GSAnimationLayer，创建地图随机生成阳光和除草机，另外控制僵尸、植物、子弹、小车事件更新。
\end_layout

\begin_layout Paragraph
GSInformationLayer.h/.cpp
\end_layout

\begin_layout Standard
定义类GSInformationLayer，展示当前是第几天的冒险之旅、僵尸进攻进度条、死亡僵尸数量、金币数量、阳光数量。
\end_layout

\begin_layout Paragraph
GSControlLayer.h/.cpp
\end_layout

\begin_layout Standard
定义类GSControlLayer，设置schedule函数循环判断控制卡片是否可以选择、植物种植位置是否合法、僵尸的文字显示与旗子更新、关卡是否结束（调用类G
SGameResultJudgement完成判断）。另外还会侦听植物卡片是否被选中。
\end_layout

\begin_layout Standard
定义结构体GameMapInformation，对应植物种植地图。
\end_layout

\begin_layout Paragraph
GSZombiesAppearControl.h/.cpp
\end_layout

\begin_layout Standard
定义类ZombiesAppearControl，控制僵尸出现波数。
\end_layout

\begin_layout Paragraph
GSButtonLayer.h/.cpp
\end_layout

\begin_layout Standard
定义类GSButtonLayer和PlantsInformation，其中类GSButtonLayer用于设置对战界面的按钮，包括铲子按钮、加速减速游戏进程按钮
、暂停按钮等；PlantsInformation定义植物冷却时间和植物所需阳光。
\end_layout

\begin_layout Paragraph
GSGameResultJudgement.h/.cpp
\end_layout

\begin_layout Standard
定义类GSGameResultJudgement，用于判断关卡是否结束，结束的条件根据关卡数据可能包含至少要收集多少阳光或保留多少小车。
\end_layout

\begin_layout Paragraph
GSGameEndLayer.h/.cpp
\end_layout

\begin_layout Standard
定义类GSGameEndLayer。用于展示各类游戏结束界面，比如因不满足游戏要求或僵尸进到家里而失败，或满足要求通关成功（奖励金币）。
\end_layout

\begin_layout Subparagraph
successfullEntry()
\end_layout

\begin_layout Standard
成功通关调用此方法，存储当前关卡数（可能废弃）、将存留下来的除草机转换为金币奖励、奖励一袋子金币。
\end_layout

\begin_layout Subparagraph
breakThrough(GameTypes gameType)
\end_layout

\begin_layout Standard
根据游戏类型显示失败界面，如果是因为僵尸进到家里失败则显示僵尸吃掉了你的脑子；如果是因为不满足游戏要求失败（比如存留下来的除草机数量不满足要求），则显示通关要求
对话框。
\end_layout

\begin_layout Subparagraph
showFailText()
\end_layout

\begin_layout Standard
显示僵尸吃掉了你的脑子，并退出游戏。
\end_layout

\begin_layout Subparagraph
showFailDialog(gameType)
\end_layout

\begin_layout Standard
显示通关要求对话框，强调失败原因。
\end_layout

\begin_layout Subparagraph
rewardThing()
\end_layout

\begin_layout Standard
奖励一袋子金币。
\end_layout

\begin_layout Subsubsection
文件夹SelectPlantsScene
\end_layout

\begin_layout Paragraph
SelectPlantsScene.h/.cpp
\end_layout

\begin_layout Standard
定义类SelectPlantsScene，选择植物界面，依次调用SPSBackgroundLayer和SPSControlLayer实现功能。
\end_layout

\begin_layout Subparagraph
eventUpdate(float Time)
\end_layout

\begin_layout Standard
包含滚动回对战的草坪、选择植物、显示游戏开始文字三类事件，分别于每隔0.22秒、0.25秒、0.3秒刷新。为了调用对应事件，需要在schedule函数中指定不同的刷新
时间。
\end_layout

\begin_layout Subparagraph
createSelectPlantsDialog()
\end_layout

\begin_layout Standard
创建选择植物对话框（通过创建SPSSpriteLayer实现）的同时，每隔0.22秒调用eventUpdate（即触发全图滚动预览事件）。
\end_layout

\begin_layout Subparagraph
selectPlantsCallBack()
\end_layout

\begin_layout Standard
创建了0.3秒的定时器
\end_layout

\begin_layout Subparagraph
replaceScene()
\end_layout

\begin_layout Standard
设置初始阳光数后跳转到GameScene。
\end_layout

\begin_layout Paragraph
SPSBackgroundLayer.h/.cpp
\end_layout

\begin_layout Standard
定义类SPSBackgroundLayer，创建选择植物界面的背景和僵尸类型的预览。
\end_layout

\begin_layout Paragraph
SPSControlLayer.h/.cpp
\end_layout

\begin_layout Standard
定义类SPSControlLayer，创建退出按钮并显示用户名字，如果退出的话会调用SPSQuitLayer弹出退出对话层。
\end_layout

\begin_layout Paragraph
SPSRequriementLayer.h/.cpp
\end_layout

\begin_layout Standard
定义类SPSRequriementLayer，通关要求对话层，具体细节通过UserWinRequirement实现，例如通关后要保留5辆小车，要求从游戏数据读取
。
\end_layout

\begin_layout Paragraph
SPSSpriteLayer.h/.cpp
\end_layout

\begin_layout Standard
定义类SPSSpriteLayer，创建选择植物界面的对话框，包括可以选择哪些植物。
\end_layout

\begin_layout Section
Cocos2d-x介绍
\end_layout

\begin_layout Standard
Cocos2d-x是使用C++开发的开源框架（又被称为游戏引擎），支持 C++/JavaScript/Lua 作为开发语言，同时允许跨平台部署。
\end_layout

\begin_layout Standard
像是刀塔传奇、梦幻西游、保卫萝卜都是使用Cocos2d-x开发的。
\end_layout

\begin_layout Subsection
文献
\end_layout

\begin_layout Standard
https://docs.cocos.com/cocos2d-x/manual/en/#，官方文档，最好的入门学习资源，可选中文版本（内容与英文版有一定区别）。
\end_layout

\begin_layout Standard
https://github.com/chukong/programmers-guide-samples，英文版教程对应示例代码。
\end_layout

\begin_layout Standard
https://discuss.cocos2d-x.org/t/how-to-run-programmers-guide-samples/26447，示例代码在Li
nux上运行的方法，似乎不可行，建议在Win上测试。
\end_layout

\begin_layout Standard
https://docs.cocos2d-x.org/api-ref/，官方API文档，比较详细。
\end_layout

\begin_layout Subsection
安装
\end_layout

\begin_layout Subsubsection
Ubuntu安装
\end_layout

\begin_layout Standard
以下仅介绍Ubuntu安装方式，其他平台参见cocos2d-x在GitHub的介绍，注意：官方教程的安装步骤已过时，最新步骤请参见cocos2dx的Github
仓库。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Enumerate
创建cocos2dx的fork，进入fork，修改文件.gitmodules中的git协议为https协议，具体步骤参见
\begin_inset CommandInset ref
LatexCommand ref
reference "par:git-clone能访问Github但是git-submodul"
plural "false"
caps "false"
noprefix "false"

\end_inset

。注意修改最新的v4 branch的同时，也要切换到v3 branch进行相应修改，因为实际开发使用v3 branch。
\end_layout

\begin_layout Enumerate
修改完成后，克隆fork仓库，此处项目地址为https://github.com/Xi-Gong/cocos2d-x/tree/v3。也可以直接克隆好执行如下命令
切换分支，但是不还没有验证切换的目标是原仓库还是克隆仓库。
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

git checkout --track origin/v3
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
按照Git官方网站给出的步骤安装依赖，此处执行 python2.7 download-deps.py，关于python2.7的安装和使用，参见
\begin_inset CommandInset ref
LatexCommand ref
reference "par:python2.7的安装"
plural "false"
caps "false"
noprefix "false"

\end_inset

。
\end_layout

\begin_layout Enumerate
执行git submodule update --init。
\end_layout

\begin_layout Enumerate
创建一个新游戏，对于Linux，需要先安装依赖，命令如下。其他步骤参见
\begin_inset CommandInset ref
LatexCommand ref
reference "par:创建新游戏"
plural "false"
caps "false"
noprefix "false"

\end_inset

。
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cd cocos2d-x/build
\end_layout

\begin_layout Plain Layout

./install-deps-linux.sh
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// 以下是安装的日志，有些依赖没有添加上，选择执行以下命令手动安装
\end_layout

\begin_layout Plain Layout

./install-deps-linux.sh: 15: DEPENDS+= libxmu-dev: not found
\end_layout

\begin_layout Plain Layout

./install-deps-linux.sh: 16: DEPENDS+= libglu1-mesa-dev: not found
\end_layout

\begin_layout Plain Layout

./install-deps-linux.sh: 17: DEPENDS+= libgl2ps-dev: not found
\end_layout

\begin_layout Plain Layout

./install-deps-linux.sh: 18: DEPENDS+= libxi-dev: not found
\end_layout

\begin_layout Plain Layout

./install-deps-linux.sh: 19: DEPENDS+= libzip-dev: not found
\end_layout

\begin_layout Plain Layout

./install-deps-linux.sh: 20: DEPENDS+= libpng-dev: not found
\end_layout

\begin_layout Plain Layout

./install-deps-linux.sh: 21: DEPENDS+= libcurl4-gnutls-dev: not found
\end_layout

\begin_layout Plain Layout

./install-deps-linux.sh: 22: DEPENDS+= libfontconfig1-dev: not found
\end_layout

\begin_layout Plain Layout

./install-deps-linux.sh: 23: DEPENDS+= libsqlite3-dev: not found
\end_layout

\begin_layout Plain Layout

./install-deps-linux.sh: 24: DEPENDS+= libglew-dev: not found
\end_layout

\begin_layout Plain Layout

./install-deps-linux.sh: 25: DEPENDS+= libssl-dev: not found
\end_layout

\begin_layout Plain Layout

./install-deps-linux.sh: 26: DEPENDS+= libgtk-3-dev: not found
\end_layout

\begin_layout Plain Layout

./install-deps-linux.sh: 27: DEPENDS+= binutils: not found
\end_layout

\begin_layout Plain Layout

./install-deps-linux.sh: 28: DEPENDS+= xorg-dev: not found
\end_layout

\begin_layout Plain Layout

W: --force-yes is deprecated, use one of the options starting with --allow
 instead.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

sudo apt install libxmu-dev libglu1-mesa-dev libgl2ps-dev libxi-dev libzip-dev
 libpng-dev libcurl4-gnutls-dev libfontconfig1-dev libsqlite3-dev libglew-dev
 libssl-dev libgtk-3-dev binutils xorg-dev
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
运行新游戏，如报错undefined reference to `__powf_finite'（Ubuntu20.04及以上可能出现此问题），参照
\begin_inset CommandInset ref
LatexCommand ref
reference "par:__powf_finite"
plural "false"
caps "false"
noprefix "false"

\end_inset

。
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cd pvz/pvz
\end_layout

\begin_layout Plain Layout

cocos run -p linux
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
undefined reference to `__powf_finite' 
\begin_inset CommandInset label
LatexCommand label
name "par:__powf_finite"

\end_inset


\end_layout

\begin_layout Standard
根本原因在于自Ubuntu 20.04开始移除了fast-math数学库。
\end_layout

\begin_layout Standard
https://stackoverflow.com/questions/63261220/link-errors-with-ffast-math-ffinite-
math-only-and-glibc-2-31，通过自定义缺少的数学函数解决问题。
\end_layout

\begin_layout Standard
具体操作步骤为，进入/home/gx/Documents/GitHub/pvz/pvz/proj.linux，修改main.cpp，增加如下代码。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#include <math.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

extern "C" {
\end_layout

\begin_layout Plain Layout

    double __exp_finite(double x) { return exp(x); }
\end_layout

\begin_layout Plain Layout

    double __log_finite(double x) { return log(x); }
\end_layout

\begin_layout Plain Layout

    double __pow_finite(double x, double y) { return pow(x, y); }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    float __expf_finite(float x) { return expf(x); }
\end_layout

\begin_layout Plain Layout

    float __logf_finite(float x) { return logf(x); }
\end_layout

\begin_layout Plain Layout

    float __powf_finite(float x, float y) { return powf(x, y); }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
python2.7的安装 
\begin_inset CommandInset label
LatexCommand label
name "par:python2.7的安装"

\end_inset


\end_layout

\begin_layout Standard
https://stackoverflow.com/questions/61486624/python-is-python-2-package-something
-new，通过创建符号链接的方式使用python2.7。
\end_layout

\begin_layout Standard
https://askubuntu.com/questions/1239829/modulenotfounderror-no-module-named-distu
tils-util，python3使用已经废弃的distutils包。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// python-is-python3 don't fit setup.py requirements
\end_layout

\begin_layout Plain Layout

// sudo apt install python-is-python3 python3-distutils
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

sudo apt install python2.7
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// 无需连接，直接调用python2.7即可
\end_layout

\begin_layout Plain Layout

// sudo ln -s /bin/python2.7 /usr/bin/python
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
git clone能访问Github但是git submodule --init就不能访问的问题 
\begin_inset CommandInset label
LatexCommand label
name "par:git-clone能访问Github但是git-submodul"

\end_inset


\end_layout

\begin_layout Standard
https://blog.csdn.net/yangjia_cheng/article/details/122179029，提出另外一种方法，删除子模块空文件夹下的.
git隐藏文件，再重新执行submodule更新，尚未尝试。
\end_layout

\begin_layout Standard
https://blog.csdn.net/qq_46695411/article/details/126273079，提出问题：git clone能访问Githu
b但是git submodule --init就不能访问，解决办法是替换.gitmodules的路径为fork的仓库，但是效率不高。
\end_layout

\begin_layout Standard
https://blog.csdn.net/sunjindeng123/article/details/124246100，替换.gitmodules的路径为Gith
ub镜像地址，尝试后发现不可行。
\end_layout

\begin_layout Standard
https://cloud.tencent.com/developer/article/1347791，介绍git协议。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
更改git协议为https协议，推荐。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

git clone https://github.com/cocos2d/cocos2d-x.git
\end_layout

\end_inset


\end_layout

\begin_layout Standard
注意：克隆时不要使用recursive。
\end_layout

\begin_layout Standard
克隆后进入目标文件夹，我的路径是/home/gx/Documents/GitHub/cocos2d。
\end_layout

\begin_layout Standard
在该路径下打开隐藏文件.gitmodules，将其中url采用的协议从git更改为https。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[submodule "tools/cocos2d-console"]
\end_layout

\begin_layout Plain Layout

        path = tools/cocos2d-console
\end_layout

\begin_layout Plain Layout

        url = https://github.com/cocos2d/cocos2d-console.git
\end_layout

\begin_layout Plain Layout

[submodule "tools/bindings-generator"]
\end_layout

\begin_layout Plain Layout

        path = tools/bindings-generator
\end_layout

\begin_layout Plain Layout

        url = https://github.com/cocos2d/bindings-generator.git
\end_layout

\begin_layout Plain Layout

[submodule "tests/cpp-tests/Resources/ccs-res"]
\end_layout

\begin_layout Plain Layout

        path = tests/cpp-tests/Resources/ccs-res
\end_layout

\begin_layout Plain Layout

        url = https://github.com/dumganhar/ccs-res.git
\end_layout

\end_inset


\end_layout

\begin_layout Standard
接下来执行同步子模块的url，然后克隆。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

git submodule sync
\end_layout

\begin_layout Plain Layout

git submodule update --init
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
还有一种方法是手动下载子模块放在指定路径下，不推荐。
\end_layout

\begin_layout Standard
即使打开VPN，执行submodule更新也失败了，观察到克隆的submodule网址和目标路径，准备手动下载submodule，拷贝到目标路径下。
\end_layout

\begin_layout Standard
Submodule 'tests/cpp-tests/Resources/ccs-res' (git://github.com/dumganhar/ccs-res.
git) registered for path 'tests/cpp-tests/Resources/ccs-res'
\end_layout

\begin_layout Standard
Submodule 'tools/bindings-generator' (git://github.com/cocos2d/bindings-generator.
git) registered for path 'tools/bindings-generator'
\end_layout

\begin_layout Standard
Submodule 'tools/cocos2d-console' (git://github.com/cocos2d/cocos2d-console.git)
 registered for path 'tools/cocos2d-console'
\end_layout

\begin_layout Standard
以ccs-res为例，此处'github.com/dumganhar/ccs-res.git'是其网址，目标路径是'tests/cpp-tests/Resource
s/ccs-res'。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
综上，以PowerShell为例，拷贝以上三个子模块的命令如下，默认上述三个子模块已经下载好并解压到你的仓库路径下（yourRepoPath）。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Copy-Item <源文件夹>  <新文件夹>  -recurse -force
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cd yourRepoPath/programmers-guide-samples/cpp/cocos2d
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// create destination dir(may not be necessary)
\end_layout

\begin_layout Plain Layout

mkdir tests/cpp-tests/Resources/ccs-res;
\end_layout

\begin_layout Plain Layout

mkdir tools/bindings-generator;
\end_layout

\begin_layout Plain Layout

mkdir tools/cocos2d-console;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// copy submodule to destination
\end_layout

\begin_layout Plain Layout

Copy-Item ../../../ccs-res-3 tests/cpp-tests/Resources/ccs-res -recurse -force;
\end_layout

\begin_layout Plain Layout

Copy-Item ../../../bindings-generator-3 tools/bindings-generator -recurse -force;
\end_layout

\begin_layout Plain Layout

Copy-Item ../../../cocos2d-console-3 tools/cocos2d-console-3 -recurse -force;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
创建新游戏 
\begin_inset CommandInset label
LatexCommand label
name "par:创建新游戏"

\end_inset


\end_layout

\begin_layout Standard
如有问题，通过cocos -h或cocos —help获取帮助。如要获取某一个具体选项的帮助，比如new，则使用cocos new -h或cocos
 new -help。
\end_layout

\begin_layout Standard
参照官方文档，编写以下创建pvz游戏的命令。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cd cocos2d-x
\end_layout

\begin_layout Plain Layout

./setup.py
\end_layout

\begin_layout Plain Layout

source FILE_TO_SAVE_SYSTEM_VARIABLE # source .bashrc
\end_layout

\begin_layout Plain Layout

cocos new pvz -p com.gx.pvz -l cpp -d ../pvz
\end_layout

\begin_layout Plain Layout

cd /home/gx/Documents/GitHub/pvz/pvz
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
官方教程示例代码配置
\end_layout

\begin_layout Standard
对于Win10，依次执行如下命令。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ cd programmers-guide-samples/cpp
\end_layout

\begin_layout Plain Layout

$ git clone https://github.com/cocos2d/cocos2d-x.git cocos2d
\end_layout

\begin_layout Plain Layout

$ cd cocos2d
\end_layout

\begin_layout Plain Layout

$ git checkout v3.10	// programmers-guide-samples branch, not cocos2dx
\end_layout

\begin_layout Plain Layout

$ git submodule update --init
\end_layout

\begin_layout Plain Layout

$ download-deps.py
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
基本概念
\end_layout

\begin_layout Standard
cocos2d-x通常包含下述组件：Renderer、2d/3d图像、碰撞检测、物理引擎、声音、控制器支持、动画、序列等。
\end_layout

\begin_layout Subsubsection
主要组件
\end_layout

\begin_layout Standard
Cocos2d-x的核心包含Scene, Node, Sprite, Menu, Menu对象。
\end_layout

\begin_layout Standard
以下图游戏为例，可以发现若干组件。
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename ../figures/cocos2dx/componentsExample.png
	lyxscale 150
	width 60text%

\end_inset


\end_layout

\begin_layout Standard
对于植物大战游戏，可以发现如下组件。
\end_layout

\begin_layout Standard
其中植物可以看作精灵，阳光数量、击杀僵尸数量、金币数可以看作标签，暂停、关卡切换等可以看作菜单项。
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename ../figures/cocos2dx/pvzExample.png
	width 60text%

\end_inset


\end_layout

\begin_layout Subsubsection
搭建游戏
\end_layout

\begin_layout Standard
跨平台代码统一存放在Classes目录下，而平台相关代码分别存放在不同文件下，即proj.android, proj.ios_mac, proj.linux,
 proj.win32。例子，https://github.com/ErLinErYi/PlantsVsZombies/tree/master/PlantsVsZo
mbies。
\end_layout

\begin_layout Standard
AppDelegate会在每个平台的代码运行时分别调用一次。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int main(int argc, char **argv)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // create the application instance
\end_layout

\begin_layout Plain Layout

    AppDelegate app;
\end_layout

\begin_layout Plain Layout

    return Application::getInstance()->run();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
设计的分辨率会影响精灵的大小的设计，以下是一些分辨率实例。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

static cocos2d::Size designResolutionSize = cocos2d::Size(480, 320);
\end_layout

\begin_layout Plain Layout

static cocos2d::Size smallResolutionSize = cocos2d::Size(480, 320);
\end_layout

\begin_layout Plain Layout

static cocos2d::Size mediumResolutionSize = cocos2d::Size(1024, 768);
\end_layout

\begin_layout Plain Layout

static cocos2d::Size largeResolutionSize = cocos2d::Size(2048, 1536);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
主要用于编码游戏的函数，AppDelegate::applicationDidFinishLaunching()。
\end_layout

\begin_layout Standard
https://blog.csdn.net/sunnyboychina/article/details/106124432，设计分辨率和屏幕分辨率的区别。
\end_layout

\begin_layout Subsubsection
改变glView的标题
\end_layout

\begin_layout Standard
注意：这不会改变IDE项目的名称或是目录名称。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if(!glview) {
\end_layout

\begin_layout Plain Layout

#if (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32) || (CC_TARGET_PLATFORM ==
 CC_PLATFORM_MAC) || (CC_TARGET_PLATFORM == CC_PLATFORM_LINUX)
\end_layout

\begin_layout Plain Layout

        glview = GLViewImpl::createWithRect("FirstGame", cocos2d::Rect(0,
 0, designResolutionSize.width, designResolutionSize.height));
\end_layout

\begin_layout Plain Layout

#else
\end_layout

\begin_layout Plain Layout

        glview = GLViewImpl::create("FirstGame");
\end_layout

\begin_layout Plain Layout

#endif
\end_layout

\begin_layout Plain Layout

        director->setOpenGLView(glview);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
导演
\end_layout

\begin_layout Standard
把你自己想象成制片人，告诉导演（Director）应该怎么做。导演类一般用于场景切换，该类产生可共享的单一实例（singleton）。以下是游戏流程，导演在其中
起到过渡的作用。
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename ../figures/cocos2dx/typicalGameFlow.png
	lyxscale 150
	width 60text%

\end_inset


\end_layout

\begin_layout Subsubsection
获取导演
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// get the director and then use it
\end_layout

\begin_layout Plain Layout

auto director = cocos2d::Director::getInstance();
\end_layout

\begin_layout Plain Layout

director->runWithScene(scene);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// get the director for each operation (not recommended for repeated requests)
\end_layout

\begin_layout Plain Layout

auto s = cocos2d::Director::getInstance()->getWinSize();
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
导演的行为
\end_layout

\begin_layout Standard
改变场景
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

director->runWithScene(scene); // use when starting your game
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

director->replaceScene(scene2); // use when changing from the running scene
 to another scene
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
暂停和播放
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// stop animations
\end_layout

\begin_layout Plain Layout

cocos2d::Director::getInstance()->stopAnimation();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// resume animations
\end_layout

\begin_layout Plain Layout

cocos2d::Director::getInstance()->startAnimation();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
获取/设置内部属性
\end_layout

\begin_layout Standard
FPS（Frame Per Second）可以理解为刷新率，即画面每秒传输帧数，帧数越多越流畅。
\end_layout

\begin_layout Standard
需要指出，FPS是由显卡的性能来决定，不是说显卡设置了刷新率120HZ，帧率就会稳定输出120HZ，它可能会波动变化，而刷新率HZ则是显示器的物理参数，它是固定
不变的。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// turn on display FPS
\end_layout

\begin_layout Plain Layout

cocos2d::Director::GetInstance()->setDisplayStats(true);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// set FPS.
 the default value is 1.0/60 if you don't call this
\end_layout

\begin_layout Plain Layout

cocos2d::Director::GetInstance()->setAnimationInterval(1.0f / 60);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// set content scale factor
\end_layout

\begin_layout Plain Layout

cocos2d::Director::GetInstance()->setContentScaleFactor(....);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Texture Cache
\end_layout

\begin_layout Standard
Texture Cache是一个存储图片数据的只读cache。
\end_layout

\begin_layout Standard
https://blog.csdn.net/wolf96/article/details/87884209，介绍Texture Cache。
\end_layout

\begin_layout Subsubsection
场景
\end_layout

\begin_layout Standard
这是一个主菜单，由一个场景（Scene）构成，而该场景又由多个部分组成。场景由renderer绘制，renderer负责组织所有出现在屏幕的部分，包括这些部分长
什么样子，该如何出现。
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename ../figures/cocos2dx/sceneExample.png
	lyxscale 150
	width 60text%

\end_inset


\end_layout

\begin_layout Subsubsection
场景图
\end_layout

\begin_layout Standard
场景图（Scene Graph）是一种安排场景内对象的数据结构，本质上是包含Node对象的树，上图对应的场景图如下。
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename ../figures/cocos2dx/2n_mainScene-sceneGraph.png
	lyxscale 150
	width 60text%

\end_inset


\end_layout

\begin_layout Standard
介绍场景图是为了解决开发中遇到对象无法正确显示的问题，比如精灵对象本来要显示在顶层，却进入了隐藏背景部分。cocos2d-x会对场景图进行中序遍历（左根右），最
后遍历（最右边）的对象将会显示在最顶层。
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename ../figures/cocos2dx/in-order-walk.png
	lyxscale 150
	width 60text%

\end_inset


\end_layout

\begin_layout Subsubsection
Z-Order
\end_layout

\begin_layout Standard
另一种理解的方式是定义z-order，z-order为负的元素在树的左侧，z-order为正的元素在树的右侧。换句话说，z-order为正的元素相比为负的元素显
示在顶层。你可以添加任意次序的任意元素，这些元素会根据自定义的z-order排序。
\end_layout

\begin_layout Standard
如下图所示，这些Node对象按照一定的z-order堆叠起来。
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename ../figures/cocos2dx/layers.png
	lyxscale 150
	width 60text%

\end_inset


\end_layout

\begin_layout Standard
在cocos2d-x中使用addChild()建立场景图。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// Adds a child with the z-order of -2, that means
\end_layout

\begin_layout Plain Layout

// it goes to the "left" side of the tree (because it is negative)
\end_layout

\begin_layout Plain Layout

scene->addChild(title_node, -2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// When you don't specify the z-order, it will use 0
\end_layout

\begin_layout Plain Layout

scene->addChild(label_node);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Adds a child with the z-order of 1, that means
\end_layout

\begin_layout Plain Layout

// it goes to the "right" side of the tree (because it is positive)
\end_layout

\begin_layout Plain Layout

scene->addChild(sprite_node, 1);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
精灵
\end_layout

\begin_layout Standard
每个游戏都有这样的情景：一个舞台，上面站着一个某种形式的主角，那主角就是精灵（Sprite）。精灵是可以移动的物体，不能移动的物体只是Node，如下图所示。
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename ../figures/cocos2dx/2n_main_sprites_nodes.png
	lyxscale 150
	width 60text%

\end_inset


\end_layout

\begin_layout Standard
精灵拥有一些可以被配置的属性，比如：位置，旋转角度，缩放比例，透明度，颜色 等等。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// This is how to create a sprite
\end_layout

\begin_layout Plain Layout

auto mySprite = Sprite::create("mysprite.png");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// this is how to change the properties of the sprite
\end_layout

\begin_layout Plain Layout

mySprite->setPosition(Vec2(500, 0));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mySprite->setRotation(40);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mySprite->setScale(2.0); // sets both the scale of the X and Y axis uniformly
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mySprite->setAnchorPoint(Vec2(0, 0));
\end_layout

\end_inset


\end_layout

\begin_layout Standard
值得一提的是锚点（anchor point）属性，该属性是setPosition()的基础。实际上，setPosition()是设置锚点的位置，而锚点的位置由s
etAnchorPoint()设置。所有Node对象都拥有一个锚点值（Sprite是Node的子类）。
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename ../figures/cocos2dx/2n_level1_anchorpoint.png
	width 60text%

\end_inset


\end_layout

\begin_layout Subsubsection
动作
\end_layout

\begin_layout Standard
动作（Action）允许Node对象在时域上进行转换，你可以在Node对象上创建一个动作序列，动作包括移动位置（Move by/Move to）、旋转（Rota
te）、伸缩（Scale）等。
\end_layout

\begin_layout Standard
移动精灵的示例代码如下，其中MoveBy执行两次移动，而MoveTo直接向目标位置移动。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

auto mySprite = Sprite::create("Blue_Front1.png");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Move a sprite 50 pixels to the right, and 10 pixels to the top over 2
 seconds.
\end_layout

\begin_layout Plain Layout

auto moveBy = MoveBy::create(2, Vec2(50,10));
\end_layout

\begin_layout Plain Layout

mySprite->runAction(moveBy);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Move a sprite to a specific location over 2 seconds.
\end_layout

\begin_layout Plain Layout

auto moveTo = MoveTo::create(2, Vec2(50,10));
\end_layout

\begin_layout Plain Layout

mySprite->runAction(moveTo);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
序列和并发
\end_layout

\begin_layout Standard
序列（Sequence）安排多个动作对象按一定顺序执行。
\end_layout

\begin_layout Standard
图示序列对应代码如下。
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename ../figures/cocos2dx/2_sequence_scaled.png
	lyxscale 150
	width 60text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

auto mySprite = Node::create();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// move to point 50,10 over 2 seconds
\end_layout

\begin_layout Plain Layout

auto moveTo1 = MoveTo::create(2, Vec2(50,10));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// move from current position by 100,10 over 2 seconds
\end_layout

\begin_layout Plain Layout

auto moveBy1 = MoveBy::create(2, Vec2(100,10));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// move to point 150,10 over 2 seconds
\end_layout

\begin_layout Plain Layout

auto moveTo2 = MoveTo::create(2, Vec2(150,10));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// create a delay
\end_layout

\begin_layout Plain Layout

auto delay = DelayTime::create(1);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mySprite->runAction(Sequence::create(moveTo1, delay, moveBy1, delay.clone(),
\end_layout

\begin_layout Plain Layout

moveTo2, nullptr));
\end_layout

\end_inset


\end_layout

\begin_layout Standard
另外，Spawn类可以使所有动作同时开始执行（即并发），但是各动作不一定同时结束（取决于动作的持续时间）。并发的场景可以是击败Boss时需要同时使用多个攻击手段
。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

auto myNode = Node::create();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

auto moveTo1 = MoveTo::create(2, Vec2(50,10));
\end_layout

\begin_layout Plain Layout

auto moveBy1 = MoveBy::create(2, Vec2(100,10));
\end_layout

\begin_layout Plain Layout

auto moveTo2 = MoveTo::create(2, Vec2(150,10));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

myNode->runAction(Spawn::create(moveTo1, moveBy1, moveTo2, nullptr));
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
结点关系
\end_layout

\begin_layout Standard
cocos2d-x的结点（Node）存在父子关系，更改父结点会同时应用于其下的子节点。
\end_layout

\begin_layout Standard
以下代码旋转父结点，子节点也一同旋转。
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename ../figures/cocos2dx/2n_parent_rotation.png
	lyxscale 150
	width 60text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

auto myNode = Node::create();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// rotating by setting
\end_layout

\begin_layout Plain Layout

myNode->setRotation(50);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
需要注意的是，不是所有的父节点属性都会被自动应用到子节点，如改变父节点的锚点只会影响转换效果(比例缩放，位置变化，角度旋转，变形等)，不会影响子节点锚点，子节点
的锚点总会是左下角 (0,0)。
\end_layout

\begin_layout Subsubsection
日志
\end_layout

\begin_layout Standard
比起C++的std::cout，log使用格式化字符串输出更方便，类似于fmt库。
\end_layout

\begin_layout Standard
注意输出std::string时，需要通过c_str()函数转换为const char *，才能正常输出，否则会乱码。
\end_layout

\begin_layout Standard
另外只有在Debug模式下，才会输出日志信息。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// a simple string
\end_layout

\begin_layout Plain Layout

log("This would be outputted to the console");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// a string and a variable
\end_layout

\begin_layout Plain Layout

string s = "My variable";
\end_layout

\begin_layout Plain Layout

cocos2d::log("string is %s", s.c_str());
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
精灵
\end_layout

\begin_layout Standard
精灵（Sprites）实际上就是一张2D图片，可以制作成动画或是改变其属性实现转换，比如旋转，移动位置，缩放等。
\end_layout

\begin_layout Subsubsection
创建精灵
\end_layout

\begin_layout Standard
可以从多种图片格式（如PNG，JPEG）创建精灵。创建精灵时默认使用图片本身的大小，即图片若是200*200，则精灵的大小也是200*200。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

auto mySprite = Sprite::create("mysprite.png");
\end_layout

\end_inset


\end_layout

\begin_layout Standard
创建精灵时也可以指定使用图片的一部分，此处使用Rect划定，四个参数依次为原点x、原点y、宽、高。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

auto mySprite = Sprite::create("mysprite.png", Rect(0,0,40,40)); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
效果如下，注意Rect从顶部左边的角落开始计算。
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ../figures/cocos2dx/rect.png
	lyxscale 150
	width 40text%

\end_inset


\end_layout

\begin_layout Subsubsection
精灵图集
\end_layout

\begin_layout Standard
精灵图集就是将精灵们合并到一个文件中，通过图集可以实现批量调用绘制函数，提高效率。
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename ../figures/cocos2dx/spritesheet.png
	lyxscale 150
	width 60text%

\end_inset


\end_layout

\begin_layout Subsubsection
加载精灵图集
\end_layout

\begin_layout Standard
使用精灵图集时，第一次要全部加载到SpriteFrameCache实例中。类SpriteFrameCache是一个缓存类，会保留添加到其中的SpriteFram
e对象（元图片）。如此一来，SpriteFrame对象只需加载一次，并保留在SpriteFrameCache中。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// load the Sprite Sheet
\end_layout

\begin_layout Plain Layout

auto spritecache = SpriteFrameCache::getInstance();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// the .plist file can be generated with any of the tools mentioned below
\end_layout

\begin_layout Plain Layout

spritecache->addSpriteFramesWithFile("sprites.plist");
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
制作精灵图集
\end_layout

\begin_layout Standard
推荐使用Texture Packer，有linux版本，https://www.codeandweb.com/texturepacker。
\end_layout

\begin_layout Subsubsection
SpriteFrame Cache
\end_layout

\begin_layout Subsubsection
从SpriteFrame名称创建
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// Our .plist file has names for each of the sprites in it.
  We'll grab
\end_layout

\begin_layout Plain Layout

// the sprite named, "mysprite" from the sprite sheet:
\end_layout

\begin_layout Plain Layout

auto mysprite = Sprite::createWithSpriteFrameName("mysprite.png");
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
从SpriteFrame创建
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// this is equivalent to the previous example,
\end_layout

\begin_layout Plain Layout

// but it is created by retrieving the SpriteFrame from the cache.
\end_layout

\begin_layout Plain Layout

auto newspriteFrame = SpriteFrameCache::getInstance()->getSpriteFrameByName("Blu
e_Front1.png");
\end_layout

\begin_layout Plain Layout

auto newSprite = Sprite::createWithSpriteFrame(newspriteFrame);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
精灵操纵
\end_layout

\begin_layout Subsubsection
锚点
\end_layout

\begin_layout Standard
锚点确定了精灵对象在计算坐标位置的一个基准点，这个点是精灵内部的点，锚点影响精灵的缩放，旋转，倾斜这种转换，不影响颜色，透明度这种属性。锚点使用的坐标系以左下角
为原点 (0, 0)，默认情况下，所有Node对象的锚点是 (0.5, 0.5)。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// DEFAULT anchor point for all Sprites
\end_layout

\begin_layout Plain Layout

mySprite->setAnchorPoint(0.5, 0.5);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// bottom left
\end_layout

\begin_layout Plain Layout

mySprite->setAnchorPoint(0, 0);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// top left
\end_layout

\begin_layout Plain Layout

mySprite->setAnchorPoint(0, 1);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// bottom right
\end_layout

\begin_layout Plain Layout

mySprite->setAnchorPoint(1, 0);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// top right
\end_layout

\begin_layout Plain Layout

mySprite->setAnchorPoint(1, 1);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
可视化之后如下图所示，其中红色是基准线。
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ../figures/cocos2dx/diffAnchorPoint.png
	lyxscale 150
	width 60text%

\end_inset


\end_layout

\begin_layout Subsubsection
位置
\end_layout

\begin_layout Standard
精灵的位置通过锚点作为基准点来确定，当我们修改锚点值时，精灵的位置也会随之改变。
\end_layout

\begin_layout Subsubsection
旋转
\end_layout

\begin_layout Standard
以锚点作为基准点旋转。精灵旋转的角度值为正或负，正值会顺时针旋转精灵对象，负值会逆时针旋转，默认旋转角度为0。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// rotate sprite by +20 degrees
\end_layout

\begin_layout Plain Layout

mySprite->setRotation(20.0f);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// rotate sprite by -20 degrees
\end_layout

\begin_layout Plain Layout

mySprite->setRotation(-20.0f);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// rotate sprite by +60 degrees
\end_layout

\begin_layout Plain Layout

mySprite->setRotation(60.0f);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// rotate sprite by -60 degrees
\end_layout

\begin_layout Plain Layout

mySprite->setRotation(-60.0f);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
可视化之后如下图所示，其中红色是基准线。
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ../figures/cocos2dx/spriteRotation.png
	width 60text%

\end_inset


\end_layout

\begin_layout Subsubsection
缩放
\end_layout

\begin_layout Standard
精灵可以沿着x轴、y轴或xy轴同时缩放。默认的缩放值是1，沿xy轴缩放。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// increases X and Y size by 2.0 uniformly
\end_layout

\begin_layout Plain Layout

mySprite->setScale(2.0);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// increases just X scale by 2.0
\end_layout

\begin_layout Plain Layout

mySprite->setScaleX(2.0);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// increases just Y scale by 2.0
\end_layout

\begin_layout Plain Layout

mySprite->setScaleY(2.0);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ../figures/cocos2dx/spriteScale.png
	width 60text%

\end_inset


\end_layout

\begin_layout Subsubsection
倾斜
\end_layout

\begin_layout Standard
和缩放相同，精灵可以沿x轴、y轴或xy轴同时倾斜。默认的倾斜值是1，沿xy轴倾斜。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// adjusts the X skew by 20.0
\end_layout

\begin_layout Plain Layout

mySprite->setSkewX(20.0f);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// adjusts the Y skew by 20.0
\end_layout

\begin_layout Plain Layout

mySprite->setSkewY(20.0f);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ../figures/cocos2dx/spriteSkew.png
	width 60text%

\end_inset


\end_layout

\begin_layout Subsubsection
颜色
\end_layout

\begin_layout Standard
通过给出包含RGB值的Color3B对象，设置精灵的颜色。cocos2dx还提供了预定义的颜色，如Color3B::Red。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// set the color by passing in a pre-defined Color3B object.
\end_layout

\begin_layout Plain Layout

mySprite->setColor(Color3B::WHITE);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Set the color by passing in a Color3B object.
\end_layout

\begin_layout Plain Layout

mySprite->setColor(Color3B(255, 255, 255)); // Same as Color3B::WHITE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ../figures/cocos2dx/spriteColor.png
	width 60text%

\end_inset


\end_layout

\begin_layout Subsubsection
透明度
\end_layout

\begin_layout Standard
透明度范围在0-255，255表示完全不透明，0表示完全透明（不可见）。默认透明度为255。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// Set the opacity to 30, which makes this sprite 11.7% opaque.
\end_layout

\begin_layout Plain Layout

// (30 divided by 256 equals 0.1171875...)
\end_layout

\begin_layout Plain Layout

mySprite->setOpacity(30);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ../figures/cocos2dx/spriteOpacity.png
	width 60text%

\end_inset


\end_layout

\begin_layout Subsubsection
多边形精灵
\end_layout

\begin_layout Standard
为了提高GPU处理图片的效率，使用多边形精灵的概念。
\end_layout

\begin_layout Standard
原本按照像素绘制，一个精灵仅用两个三角形就可以绘制；现在为了节省绘制资源，改为沿顶点绘制，绘制时划分为更多三角形。
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename ../figures/cocos2dx/polygonsprite.png
	lyxscale 150
	width 60text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// Generate polygon info automatically.
\end_layout

\begin_layout Plain Layout

auto pinfo = AutoPolygon::generatePolygon("filename.png");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Create a sprite with polygon info.
\end_layout

\begin_layout Plain Layout

auto sprite = Sprite::create(pinfo);
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
动作
\end_layout

\begin_layout Standard
动作（Action）对象通过修改结点属性制造变换。
\end_layout

\begin_layout Subsubsection
MoveBy和MoveTo的区别
\end_layout

\begin_layout Standard
MoveBy是在当前位置的基础上移动，是相对的。MoveTo是直接移动到给定位置，是绝对的。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

auto mySprite = Sprite::create("mysprite.png");
\end_layout

\begin_layout Plain Layout

mySprite->setPosition(Vec2(200, 256));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// MoveBy - lets move the sprite by 500 on the x axis over 2 seconds
\end_layout

\begin_layout Plain Layout

// MoveBy is relative - since x = 200 + 500 move = x is now 700 after the
 move
\end_layout

\begin_layout Plain Layout

auto moveBy = MoveBy::create(2, Vec2(500, mySprite->getPositionY()));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// MoveTo - lets move the new sprite to 300 x 256 over 2 seconds
\end_layout

\begin_layout Plain Layout

// MoveTo is absolute - The sprite gets moved to 300 x 256 regardless of
\end_layout

\begin_layout Plain Layout

// where it is located now.
\end_layout

\begin_layout Plain Layout

auto moveTo = MoveTo::create(2, Vec2(300, mySprite->getPositionY()));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Delay - create a small delay
\end_layout

\begin_layout Plain Layout

auto delay = DelayTime::create(1);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

auto seq = Sequence::create(moveBy, delay, moveTo, nullptr);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mySprite->runAction(seq);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename ../figures/cocos2dx/MoveByThenMoveTo.png
	lyxscale 150
	width 60text%

\end_inset


\end_layout

\begin_layout Subsubsection
基本动作
\end_layout

\begin_layout Subsubsection
Move, Rotate, Scale, Tint, Fade
\end_layout

\begin_layout Standard
这些基本动作都有共通的用法，每个动作都有XXBy和XXTo方法，分别对应相对和绝对的操作。Fade略有区别，对应Fade In/Out。
\end_layout

\begin_layout Subsubsection
Animate
\end_layout

\begin_layout Standard
Animate对象很容易实现“翻页式”的动画，即每隔一个短暂时间进行图像替代。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

auto mySprite = Sprite::create("mysprite.png");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// now lets animate the sprite we moved
\end_layout

\begin_layout Plain Layout

Vector<SpriteFrame*> animFrames;
\end_layout

\begin_layout Plain Layout

animFrames.reserve(12);
\end_layout

\begin_layout Plain Layout

animFrames.pushBack(SpriteFrame::create("Blue_Front1.png", Rect(0,0,65,81)));
\end_layout

\begin_layout Plain Layout

animFrames.pushBack(SpriteFrame::create("Blue_Front2.png", Rect(0,0,65,81)));
\end_layout

\begin_layout Plain Layout

animFrames.pushBack(SpriteFrame::create("Blue_Front3.png", Rect(0,0,65,81)));
\end_layout

\begin_layout Plain Layout

animFrames.pushBack(SpriteFrame::create("Blue_Left1.png", Rect(0,0,65,81)));
\end_layout

\begin_layout Plain Layout

animFrames.pushBack(SpriteFrame::create("Blue_Left2.png", Rect(0,0,65,81)));
\end_layout

\begin_layout Plain Layout

animFrames.pushBack(SpriteFrame::create("Blue_Left3.png", Rect(0,0,65,81)));
\end_layout

\begin_layout Plain Layout

animFrames.pushBack(SpriteFrame::create("Blue_Back1.png", Rect(0,0,65,81)));
\end_layout

\begin_layout Plain Layout

animFrames.pushBack(SpriteFrame::create("Blue_Back2.png", Rect(0,0,65,81)));
\end_layout

\begin_layout Plain Layout

animFrames.pushBack(SpriteFrame::create("Blue_Back3.png", Rect(0,0,65,81)));
\end_layout

\begin_layout Plain Layout

animFrames.pushBack(SpriteFrame::create("Blue_Right1.png", Rect(0,0,65,81)));
\end_layout

\begin_layout Plain Layout

animFrames.pushBack(SpriteFrame::create("Blue_Right2.png", Rect(0,0,65,81)));
\end_layout

\begin_layout Plain Layout

animFrames.pushBack(SpriteFrame::create("Blue_Right3.png", Rect(0,0,65,81)));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// create the animation out of the frames
\end_layout

\begin_layout Plain Layout

Animation* animation = Animation::createWithSpriteFrames(animFrames, 0.1f);
\end_layout

\begin_layout Plain Layout

Animate* animate = Animate::create(animation);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// run it and repeat it forever
\end_layout

\begin_layout Plain Layout

mySprite->runAction(RepeatForever::create(animate));
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Easing（变速运动）
\end_layout

\begin_layout Standard
变速动作可以让节点对象具有加速度，产生平滑同时相对复杂的动作，所以可以用变速动作来模仿一些物理运动，这样比实际使用物理引擎的性能消耗低，使用起来也简单。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// create a sprite
\end_layout

\begin_layout Plain Layout

auto mySprite = Sprite::create("mysprite.png");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// create a MoveBy Action to where we want the sprite to drop from.
\end_layout

\begin_layout Plain Layout

auto move = MoveBy::create(2, Vec2(200, dirs->getVisibleSize().height -
\end_layout

\begin_layout Plain Layout

 newSprite2->getContentSize().height));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// create a BounceIn Ease Action
\end_layout

\begin_layout Plain Layout

auto move_ease_in = EaseBounceIn::create(move->clone() );
\end_layout

\begin_layout Plain Layout

auto move_ease_in_back = move_ease_in->reverse();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// create a delay that is run in between sequence events
\end_layout

\begin_layout Plain Layout

auto delay = DelayTime::create(0.25f);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// create the sequence of actions, in the order we want to run them
\end_layout

\begin_layout Plain Layout

auto seq1 = Sequence::create(move_ease_in, delay, move_ease_in_back,
\end_layout

\begin_layout Plain Layout

    delay->clone(), nullptr);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// run the sequence and repeat forever.
\end_layout

\begin_layout Plain Layout

mySprite->runAction(RepeatForever::create(seq1));
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
序列
\end_layout

\begin_layout Subsubsection
加入函数
\end_layout

\begin_layout Standard
序列（Sequence）可以连续执行的一系列Action对象。除了Action对象之外，为了增加灵活性，序列中还可以包含函数，即CallFunc对象。
\end_layout

\begin_layout Standard
CallFunc::create可以创建回调函数，回调函数的定义：如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们
就说这是回调函数。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

auto mySprite = Sprite::create("mysprite.png");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// create a few actions.
\end_layout

\begin_layout Plain Layout

auto jump = JumpBy::create(0.5, Vec2(0, 0), 100, 1);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

auto rotate = RotateTo::create(2.0f, 10);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// create a few callbacks
\end_layout

\begin_layout Plain Layout

auto callbackJump = CallFunc::create([](){
\end_layout

\begin_layout Plain Layout

    log("Jumped!");
\end_layout

\begin_layout Plain Layout

});
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

auto callbackRotate = CallFunc::create([](){
\end_layout

\begin_layout Plain Layout

    log("Rotated!");
\end_layout

\begin_layout Plain Layout

});
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// create a sequence with the actions and callbacks
\end_layout

\begin_layout Plain Layout

auto seq = Sequence::create(jump, callbackJump, rotate, callbackRotate,
 nullptr);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// run it
\end_layout

\begin_layout Plain Layout

mySprite->runAction(seq);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
加入延迟
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cocos2d::DelayTime* delay = cocos2d::DelayTime::create(1);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// A, B, C is callback fun created by CallFunc
\end_layout

\begin_layout Plain Layout

runAction(cocos2d::Sequence::create(A, delay, B, delay, C, NULL));
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Spawn
\end_layout

\begin_layout Standard
如前所述，Spawn对象允许同时执行多个Action对象，其效果和连续执行相同。
\end_layout

\begin_layout Standard
使用Spawn对象可以获得连续执行所不能获得的效果。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// create 2 actions and run a Spawn on a Sprite
\end_layout

\begin_layout Plain Layout

auto mySprite = Sprite::create("mysprite.png");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

auto moveBy = MoveBy::create(10, Vec2(400,100));
\end_layout

\begin_layout Plain Layout

auto fadeTo = FadeTo::create(2.0f, 120.0f);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// running the above Actions with Spawn.
\end_layout

\begin_layout Plain Layout

auto mySpawn = Spawn::createWithTwoActions(moveBy, fadeTo);
\end_layout

\begin_layout Plain Layout

mySprite->runAction(mySpawn);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
另外可以在序列中包含Spawn对象，如下图所示。
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ../figures/cocos2dx/spawn_in_a_sequence.png
	lyxscale 150
	width 60text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// create a Sprite
\end_layout

\begin_layout Plain Layout

auto mySprite = Sprite::create("mysprite.png");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// create a few Actions
\end_layout

\begin_layout Plain Layout

auto moveBy = MoveBy::create(10, Vec2(400,100));
\end_layout

\begin_layout Plain Layout

auto fadeTo = FadeTo::create(2.0f, 120.0f);
\end_layout

\begin_layout Plain Layout

auto scaleBy = ScaleBy::create(2.0f, 3.0f);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// create a Spawn to use
\end_layout

\begin_layout Plain Layout

auto mySpawn = Spawn::createWithTwoActions(scaleBy, fadeTo);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// tie everything together in a sequence
\end_layout

\begin_layout Plain Layout

auto seq = Sequence::create(moveBy, mySpawn, moveBy, nullptr);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// run it
\end_layout

\begin_layout Plain Layout

mySprite->runAction(seq);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Clone和Reverse
\end_layout

\begin_layout Subsubsection
Clone
\end_layout

\begin_layout Standard
当我们将同一动作施加到多个Node对象时，需要考虑Action对象的拷贝问题。原因在于每个Action对象都有自己的内部状态（internal
 state），Action对象执行之后，其内部状态也会改变，如果再次使用同一对象会出现难以预料的结果。
\end_layout

\begin_layout Standard
考虑下面的例子。
\end_layout

\begin_layout Standard
如果有一个heroSprite对象在原点(0, 0)处，在其上执行以下Action对象。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MoveBy::create(10, Vec2(400,100));
\end_layout

\end_inset


\end_layout

\begin_layout Standard
执行后，heroSprite会被移动到(400, 100)处，此时该Action对象的内部状态也发生了改变，其内记录了目前的位置是(400, 100)。
\end_layout

\begin_layout Standard
现在引入enemySprite对象，在(200, 200)处，对其施加相同的Action对象，最终enemySprite会被移动到(800, 200)处（相对A
ction对象的内部状态），而非预期的位置。
\end_layout

\begin_layout Standard
而Clone方法可以解决此问题，该方法返回引用（Ref对象）的拷贝，是深拷贝。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// create our Sprites
\end_layout

\begin_layout Plain Layout

auto heroSprite = Sprite::create("herosprite.png");
\end_layout

\begin_layout Plain Layout

auto enemySprite = Sprite::create("enemysprite.png");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// create an Action
\end_layout

\begin_layout Plain Layout

auto moveBy = MoveBy::create(10, Vec2(400,100));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// run it on our hero
\end_layout

\begin_layout Plain Layout

heroSprite->runAction(moveBy);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// run it on our enemy
\end_layout

\begin_layout Plain Layout

enemySprite->runAction(moveBy->clone()); // correct! This will be unique
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Reverse
\end_layout

\begin_layout Standard
调用reverse()方法不仅仅是反向执行序列或Spawn中的动作，实际上是以相反的方向操纵序列或Spawn中的属性。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// reverse a sequence, spawn or action
\end_layout

\begin_layout Plain Layout

mySprite->runAction(mySpawn->reverse());
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
场景
\end_layout

\begin_layout Standard
场景（Scene）中包含创建游戏所需的Sprites, Labels, Nodes对象等。游戏内可以有许多Scene对象并在之间切换，切换效果也可以自定义。
\end_layout

\begin_layout Subsubsection
创建场景
\end_layout

\begin_layout Standard
创建场景很简单。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

auto myScene = Scene::create();
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
scene(), create(), init() 调用关系
\end_layout

\begin_layout Standard
https://blog.csdn.net/wozhengtao/article/details/54600199。
\end_layout

\begin_layout Standard
示例。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class LoadingScene :public Scene
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

public:
\end_layout

\begin_layout Plain Layout

	// 生成LoadingScene的create函数
\end_layout

\begin_layout Plain Layout

	CREATE_FUNC(LoadingScene);
\end_layout

\begin_layout Plain Layout

	// ...
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/** @def CREATE_FUNC(__TYPE__)
\end_layout

\begin_layout Plain Layout

 * Define a create function for a specific type, such as Layer.
\end_layout

\begin_layout Plain Layout

 *
\end_layout

\begin_layout Plain Layout

 * @param __TYPE__  class type to add create(), such as Layer.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

#define CREATE_FUNC(__TYPE__) 
\backslash

\end_layout

\begin_layout Plain Layout

static __TYPE__* create() 
\backslash

\end_layout

\begin_layout Plain Layout

{ 
\backslash

\end_layout

\begin_layout Plain Layout

    __TYPE__ *pRet = new(std::nothrow) __TYPE__(); 
\backslash

\end_layout

\begin_layout Plain Layout

	// create函数会调用所给类中的init成员函数
\end_layout

\begin_layout Plain Layout

    if (pRet && pRet->init()) 
\backslash

\end_layout

\begin_layout Plain Layout

    { 
\backslash

\end_layout

\begin_layout Plain Layout

        pRet->autorelease(); 
\backslash

\end_layout

\begin_layout Plain Layout

        return pRet; 
\backslash

\end_layout

\begin_layout Plain Layout

    } 
\backslash

\end_layout

\begin_layout Plain Layout

    else 
\backslash

\end_layout

\begin_layout Plain Layout

    { 
\backslash

\end_layout

\begin_layout Plain Layout

        delete pRet; 
\backslash

\end_layout

\begin_layout Plain Layout

        pRet = nullptr; 
\backslash

\end_layout

\begin_layout Plain Layout

        return nullptr; 
\backslash

\end_layout

\begin_layout Plain Layout

    } 
\backslash

\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
场景图和Z-Order
\end_layout

\begin_layout Standard
场景图决定了场景内节点对象的渲染顺序，也要记得 z-order 是如何影响场景图的。
\end_layout

\begin_layout Subsubsection
一个简单场景
\end_layout

\begin_layout Standard
Cocos2d-x用右手坐标系，也就是说坐标原点(0,0)在展示区的左下角，当你在场景里放置一些节点对象设置坐标位置时，注意左下角是坐标计算的起点。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

auto dirs = Director::getInstance();
\end_layout

\begin_layout Plain Layout

Size visibleSize = dirs->getVisibleSize();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

auto myScene = Scene::create();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

auto label1 = Label::createWithTTF("My Game", "Marker Felt.ttf", 36);
\end_layout

\begin_layout Plain Layout

label1->setPosition(Vec2(visibleSize.width / 2, visibleSize.height / 2));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

myScene->addChild(label1);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

auto sprite1 = Sprite::create("mysprite.png");
\end_layout

\begin_layout Plain Layout

sprite1->setPosition(Vec2(100, 100));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

myScene->addChild(sprite1);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
场景切换
\end_layout

\begin_layout Subsubsection
切换方法
\end_layout

\begin_layout Standard
场景切换有很多方式，每种方式对应的方法通过如下模式调用。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Director::getInstance()->XXScene(myScene);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
runWithScene()，用于开始游戏，加载第一个场景（只用于第一个场景！）。
\end_layout

\begin_layout Standard
replaceScene()，使用传入的场景替换当前场景来切换画面，当前场景被释放。这是切换场景时最常用的方法。
\end_layout

\begin_layout Standard
pushScene()，将当前运行中的场景暂停并压入到场景栈中，再将传入的场景设置为当前运行场景。只有存在正在运行的场景时才能调用该方法。
\end_layout

\begin_layout Standard
popScene()，释放当前场景，再从场景栈中弹出栈顶的场景，并将其设置为当前运行场景。如果栈为空，直接结束应用。
\end_layout

\begin_layout Subsubsection
切换效果
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

auto myScene = Scene::create();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Transition Fade
\end_layout

\begin_layout Plain Layout

Director::getInstance()->replaceScene(TransitionFade::create(0.5, myScene,
 Color3B(0,255,255)));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// FlipX
\end_layout

\begin_layout Plain Layout

Director::getInstance()->replaceScene(TransitionFlipX::create(2, myScene));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Transition Slide In
\end_layout

\begin_layout Plain Layout

Director::getInstance()->replaceScene(TransitionSlideInT::create(1, myScene)
 );
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
UI组件
\end_layout

\begin_layout Standard
像是labels, buttons, menus, sliders and views都是UI组件。
\end_layout

\begin_layout Subsubsection
标签
\end_layout

\begin_layout Standard
Cocos2d-x 提供标签（Label）对象给用户，可以使用位图字体，TrueType 字体，系统字体创建标签。
\end_layout

\begin_layout Subsubsection
位图字体
\end_layout

\begin_layout Standard
位图字体（BMFont）是一个使用位图字体创建的标签类型，位图字体中的字符由点阵组成。这种字体标签性能好，但是缩放会失真。标签中的每个字符都是一个单独的
 Sprite，也就是说精灵的属性控制适用于这里的每个字符。
\end_layout

\begin_layout Standard
创建 BMFont 标签需要两个文件：.fnt 文件和 .png 文件。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

auto myLabel = Label::createWithBMFont("bitmapRed.fnt", "Your Text");
\end_layout

\end_inset


\end_layout

\begin_layout Standard
注意：在标签中出现的字符应能在提供的 .fnt 文件找到，如果找不到，字符就不会被渲染。
\end_layout

\begin_layout Standard
下面要介绍的其他字体效果均参见此图。
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ../figures/cocos2dx/LabelAllFont.png
	lyxscale 150
	width 60text%

\end_inset


\end_layout

\begin_layout Subsubsection
TrueType字体
\end_layout

\begin_layout Standard
TrueType字体（TTF）不需要为每种尺寸和颜色单独使用字体文件。不像 BMFont，如果想不失真的缩放，就要提供多种字体文件。
\end_layout

\begin_layout Standard
虽然使用TrueType字体更灵活，但是显示的时间更长，并且更改如font face和size的属性需要付出昂贵的代价。
\end_layout

\begin_layout Standard
要创建这种标签，需要指定 .ttf 字体文件名，文本字符串和字体大小。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

auto myLabel = Label::createWithTTF("Your Text", "Marker Felt.ttf", 24);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
TTF Config
\end_layout

\begin_layout Standard
如果你创建了多个相同属性的TrueType字体，那么可以使用TTFConfig管理他们。TTFConfig允许你设置TTF对象的共有属性。
\end_layout

\begin_layout Standard
另外TTFConfig还可以用于显示中文。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// create a TTFConfig files for labels to share
\end_layout

\begin_layout Plain Layout

TTFConfig labelConfig;
\end_layout

\begin_layout Plain Layout

labelConfig.fontFilePath = "myFont.ttf";
\end_layout

\begin_layout Plain Layout

labelConfig.fontSize = 16;
\end_layout

\begin_layout Plain Layout

labelConfig.glyphs = GlyphCollection::DYNAMIC;
\end_layout

\begin_layout Plain Layout

labelConfig.outlineSize = 0;
\end_layout

\begin_layout Plain Layout

labelConfig.customGlyphs = nullptr;
\end_layout

\begin_layout Plain Layout

labelConfig.distanceFieldEnabled = false;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// create a TTF Label from the TTFConfig file.
\end_layout

\begin_layout Plain Layout

auto myLabel = Label::createWithTTF(labelConfig, "My Label Text");
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
系统字体
\end_layout

\begin_layout Standard
系统字体（System Font）是使用默认系统字体和字体大小的Label对象，因此其属性不可改变。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

auto myLabel = Label::createWithSystemFont("My Label Text", "Arial", 16);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
字体特效
\end_layout

\begin_layout Standard
Cocos2dx提供字体特效，覆盖大部分需求，因此无需自定义字体。不同字体支持特定的特效。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

auto myLabel = Label::createWithTTF("My Label Text", "myFont.ttf", 16);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// shadow effect is supported by all Label types
\end_layout

\begin_layout Plain Layout

myLabel->enableShadow();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// outline effect is TTF only, specify the outline color desired
\end_layout

\begin_layout Plain Layout

myLabel->enableOutline(Color4B::WHITE, 1));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// glow effect is TTF only, specify the glow color desired.
\end_layout

\begin_layout Plain Layout

myLabel->enableGlow(Color4B::YELLOW);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
菜单
\end_layout

\begin_layout Standard
菜单通常包含开始、退出、设置、关于等项，也可以包含子菜单，没有菜单项的菜单没有存在的意义。Cocos2d-x提供Menu对象支持菜单功能，Menu对象是一种特殊
的Node对象。
\end_layout

\begin_layout Standard
菜单项一般有正常状态和选择状态。菜单项显示时是正常状态，当你点击它时变为选择状态，同时点击菜单还会触发一个回调函数。
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename ../figures/cocos2dx/menu.png
	lyxscale 150
	width 60text%

\end_inset


\end_layout

\begin_layout Subsubsection
创建菜单
\end_layout

\begin_layout Standard
以下给出创建菜单的一些方法，包括创建空菜单，使用图像创建菜单，使用包含MenuItem的vector创建菜单。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// creating a emtpy menu
\end_layout

\begin_layout Plain Layout

auto myMenu = Menu::create();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// -------------------------------------
\end_layout

\begin_layout Plain Layout

// creating a menu with a single item
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// create a menu item by specifying images
\end_layout

\begin_layout Plain Layout

auto closeItem = MenuItemImage::create("CloseNormal.png", "CloseSelected.png",
\end_layout

\begin_layout Plain Layout

CC_CALLBACK_1(HelloWorld::menuCloseCallback, this));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

auto menu = Menu::create(closeItem, NULL);
\end_layout

\begin_layout Plain Layout

this->addChild(menu, 1);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// --------------------------------------
\end_layout

\begin_layout Plain Layout

// creating a Menu from a Vector of items
\end_layout

\begin_layout Plain Layout

Vector<MenuItem*> MenuItems;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

auto closeItem = MenuItemImage::create("CloseNormal.png", "CloseSelected.png",
\end_layout

\begin_layout Plain Layout

CC_CALLBACK_1(HelloWorld::menuCloseCallback, this));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

MenuItems.pushBack(closeItem);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* repeat for as many menu items as needed */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

auto menu = Menu::createWithArray(MenuItems);
\end_layout

\begin_layout Plain Layout

this->addChild(menu, 1);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
使用Lambda表达式
\end_layout

\begin_layout Standard
点击菜单项将会触发回调函数，该函数可以是Lambda表达式。
\end_layout

\begin_layout Standard
注意：Lambda表达式在运行时（runtime）检查，而非编译时。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

auto closeItem = MenuItemImage::create("CloseNormal.png", "CloseSelected.png",
\end_layout

\begin_layout Plain Layout

[&](Ref* sender){
\end_layout

\begin_layout Plain Layout

    // your code here
\end_layout

\begin_layout Plain Layout

});
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
按钮
\end_layout

\begin_layout Standard
按钮会拦截点击事件，事件触发时调用事先定义好的回调函数。按钮有一个正常状态，一个选择状态，还有一个不可点击状态，按钮的外观可以根据这三个状态而改变。记得在操作的
时候要包含头文件: #include "ui/CocosGUI.h"。
\end_layout

\begin_layout Standard
在屏幕显示时，同一时刻只能看见按钮的一个状态。
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ../figures/cocos2dx/Button_example.png
	lyxscale 150
	width 60text%

\end_inset


\end_layout

\begin_layout Standard
以下代码为按钮每个状态都指定了一个png图像。
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ../figures/cocos2dx/buttonState.png
	width 60text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

auto button = Button::create("normal_image.png", "selected_image.png", "disabled_i
mage.png");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

button->setTitleText("Button Text");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

button->addTouchEventListener([&](Ref* sender, Widget::TouchEventType type){
\end_layout

\begin_layout Plain Layout

        switch (type)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

                case ui::Widget::TouchEventType::BEGAN:
\end_layout

\begin_layout Plain Layout

                        break;
\end_layout

\begin_layout Plain Layout

                case ui::Widget::TouchEventType::ENDED:
\end_layout

\begin_layout Plain Layout

                        std::cout << "Button 1 clicked" << std::endl;
\end_layout

\begin_layout Plain Layout

                        break;
\end_layout

\begin_layout Plain Layout

                default:
\end_layout

\begin_layout Plain Layout

                        break;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

});
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

this->addChild(button);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
复选框
\end_layout

\begin_layout Standard
复选框允许用户进行二分选择（0或者1）。
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ../figures/cocos2dx/Checkbox_example.png
	lyxscale 150
	width 60text%

\end_inset


\end_layout

\begin_layout Standard
复选框有5种状态：正常状态、正常按下状态、选择状态、正常不可点击状态、选择不可点击状态，每种状态对应一张图片。
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ../figures/cocos2dx/checkboxState.png
	width 60text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#include "ui/CocosGUI.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

auto checkbox = CheckBox::create("check_box_normal.png",
\end_layout

\begin_layout Plain Layout

                                 "check_box_normal_press.png",
\end_layout

\begin_layout Plain Layout

                                 "check_box_active.png",
\end_layout

\begin_layout Plain Layout

                                 "check_box_normal_disable.png",
\end_layout

\begin_layout Plain Layout

                                 "check_box_active_disable.png");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

checkbox->addTouchEventListener([&](Ref* sender, Widget::TouchEventType
 type){
\end_layout

\begin_layout Plain Layout

        switch (type)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

                case ui::Widget::TouchEventType::BEGAN:
\end_layout

\begin_layout Plain Layout

                        break;
\end_layout

\begin_layout Plain Layout

                case ui::Widget::TouchEventType::ENDED:
\end_layout

\begin_layout Plain Layout

                        std::cout << "checkbox 1 clicked" << std::endl;
\end_layout

\begin_layout Plain Layout

                        break;
\end_layout

\begin_layout Plain Layout

                default:
\end_layout

\begin_layout Plain Layout

                        break;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

});
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

this->addChild(checkbox);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
进度条
\end_layout

\begin_layout Standard
游戏加载一般都需要进度条。
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ../figures/cocos2dx/LoadingBar_example.png
	lyxscale 150
	width 60text%

\end_inset


\end_layout

\begin_layout Standard
进度条的图片。
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ../figures/cocos2dx/LoadingBarFile.png
	lyxscale 150
	width 60text%

\end_inset


\end_layout

\begin_layout Standard
以下代码创建了一个进度条，设置了当进度增加时，进度条向右填充，在一些事件发生后同时改变进度条的进度。
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#include "ui/CocosGUI.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

auto loadingBar = LoadingBar::create("LoadingBarFile.png");
\end_layout

\begin_layout Plain Layout

loadingBar->setDirection(LoadingBar::Direction::RIGHT);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// something happened, change the percentage of the loading bar
\end_layout

\begin_layout Plain Layout

loadingBar->setPercent(25);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// more things happened, change the percentage again.
\end_layout

\begin_layout Plain Layout

loadingBar->setPercent(35);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

this->addChild(loadingBar);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
滑动条
\end_layout

\begin_layout Standard
有时候你想平滑的改变一个值，比如游戏设置中，调整背景音乐的音量，这时就要用到滑动条（Slider）。
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ../figures/cocos2dx/Slider_example.png
	lyxscale 150
	width 60text%

\end_inset


\end_layout

\begin_layout Standard
实现一个滑动条需要提供五张图像，对应滑动条的不同部分不同状态，分别为：滑动条背景，上层进度条，正常显示时的滑动端点，滑动时的滑动端点，不可用时的滑动端点。
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ../figures/cocos2dx/sliderStates.png
	width 60text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#include "ui/CocosGUI.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

auto slider = Slider::create();
\end_layout

\begin_layout Plain Layout

slider->loadBarTexture("Slider_Back.png"); // what the slider looks like
\end_layout

\begin_layout Plain Layout

slider->loadSlidBallTextures("SliderNode_Normal.png", "SliderNode_Press.png",
 "SliderNode_Disable.png");
\end_layout

\begin_layout Plain Layout

slider->loadProgressBarTexture("Slider_PressBar.png");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

slider->addTouchEventListener([&](Ref* sender, Widget::TouchEventType type){
\end_layout

\begin_layout Plain Layout

        switch (type)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

                case ui::Widget::TouchEventType::BEGAN:
\end_layout

\begin_layout Plain Layout

                        break;
\end_layout

\begin_layout Plain Layout

                case ui::Widget::TouchEventType::ENDED:
\end_layout

\begin_layout Plain Layout

                        std::cout << "slider moved" << std::endl;
\end_layout

\begin_layout Plain Layout

                        break;
\end_layout

\begin_layout Plain Layout

                default:
\end_layout

\begin_layout Plain Layout

                        break;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

});
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

this->addChild(slider);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
文本框
\end_layout

\begin_layout Standard
Cocos2d-x提供TextField满足输入文本的需求。它支持触摸事件，焦点，定位内容百分比等。提供的文本框对象，是多功能的，能满足所有的输入需求，比如用户
密码的输入，限制用户可以输入的字符数等等！
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#include "ui/CocosGUI.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

auto textField = TextField::create("","Arial",30);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// make this TextField password enabled
\end_layout

\begin_layout Plain Layout

textField->setPasswordEnabled(true);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// set the maximum number of characters the user can enter for this TextField
\end_layout

\begin_layout Plain Layout

textField->setMaxLength(10);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

textField->addTouchEventListener([&](Ref* sender, Widget::TouchEventType
 type){
\end_layout

\begin_layout Plain Layout

                std::cout << "editing a TextField" << std::endl;
\end_layout

\begin_layout Plain Layout

});
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

this->addChild(textField);
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
界面
\end_layout

\begin_layout Standard
一般使用界面代指Layer，继承自Node，用于Scene下。
\end_layout

\begin_layout Standard
https://blog.csdn.net/lttree/article/details/37997925，Layer的介绍，不太正式。
\end_layout

\begin_layout Standard
https://www.cnblogs.com/as3lib/p/3895843.html，Scene，Layer，Sprite的关系。
\end_layout

\begin_layout Standard
https://www.zhihu.com/question/28233034，为什么在cocos2d-x中，大家都喜欢用Layer而不是Scene？
\end_layout

\begin_layout Subsection
进阶话题
\end_layout

\begin_layout Standard
关于进阶话题，由于介绍已经足够凝练，请自行参考：https://docs.cocos.com/cocos2d-x/manual/zh/#
\end_layout

\begin_layout Subsection
调度器
\end_layout

\begin_layout Standard
https://blog.csdn.net/u010229677/article/details/14107903，项目中的scheduleOnce函数对应文章中对
于schedule的讲解。
\end_layout

\begin_layout Subsection
宏
\end_layout

\begin_layout Standard
cocos2dx中为了简化代码，定义了大量实用的宏。
\end_layout

\begin_layout Subsubsection
宏USING_NS_CC
\end_layout

\begin_layout Standard
宏USING_NS_CC（Using NameSpace CoCos）等价于using namespace cocos2d。
\end_layout

\begin_layout Standard
https://discuss.cocos2d-x.org/t/using-ns-cc-in-header-file/56178，不应在头文件使用宏USING_NS
_CC。
\end_layout

\end_body
\end_document
